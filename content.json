{"pages":[{"title":"抓住你了😝","text":"生有涯而知无崖 在此记录记录点滴 如有错误，请指正，以免误导下一位读者 谢谢 !!","link":"/about/index.html"}],"posts":[{"title":"CSS3 的边框","text":"CSS3 新增了边框圆角、边框阴影、边框图片特性 border-radius首先要理解圆、圆心、长半径、短半径的概念，正圆是椭圆的一种特殊情况 border-radius 属性可设置四个值，分别表示四个圆角。并且可以设置两组，第一组表示横轴半径，第二组表示纵轴半径。 可分别设置长、短半径，以“/”进行分隔，遵循“1，2，3，4”规则，“/”前面的1~4个用来设置横轴半径（分别对应横轴1、2、3、4位置 ），“/”后面1~4个参数用来设置纵轴半径（分别对应纵轴1、2、3、4位置 ） 1234/* 四个圆角是一样的特殊情况 */div { border-radius: 4px 4px 4px 4px / 4px 4px 4px 4px;} 当圆角半径小于或等于边框宽度时，元素内角是直角 box-shoadowbox-shoadow: [inset] h-shadow v-shadow [blur spread color]; inset 设置内置阴影h-shadow 水平偏移量v-shadow 垂直偏移量blur 模糊度spread 阴影扩展color 阴影颜色 特点水平偏移量 正值向右 负值向左 垂直正值向下 负值向上。模糊度是不能为负关于模糊度：从一个颜色值在一定距离内进行一个渐变至透明的过程。移量和扩展也是数学运算的，即正负会相互抵消。偏移量和模糊度是可以相加计算，偏移量负号只代表方向。设置边框阴影不会影响盒子的布局，即不会影响其兄弟元素的布局。spread可以与blur、h-shadow、v-shadow相互抵消，blur不可为负值可以设置多重边框阴影，实现更好的效果，增强立体感 border-image — The End —","link":"/css/2017/03/02/"},{"title":"css 时钟","text":"用 CSS3 画一个时钟，由定时器驱动，代码有点长。。。 /* 轮廓 */ #example_clock { margin: 1.0em auto; width: 22.0em; height: 22.0em; position: relative; border: 1.0em solid rgba(0, 0, 0, 0.7); background-color: #fff; border-radius: 50%; box-shadow: 0 0 1.5em #333; } /* 12 个刻度 */ #example_clock #example_tick ins { display: block; width: 19.8em; height: 0.3em; border-radius: 0.3em; background-image: linear-gradient(90deg, red 6%, transparent 6%, transparent 94%, red 94%, red 100%); position: absolute; top: 50%; left: 50%; margin: -0.15em 0 0 -9.9em; } #example_clock #example_tick ins:nth-child(n+3) { background-image: linear-gradient(90deg, grey 6%, transparent 6%, transparent 94%, grey 94%, grey 100%); } #example_clock #example_tick ins:first-child { transform: rotateZ(90deg); } #example_clock #example_tick ins:nth-child(3) { transform: rotateZ(30deg); } #example_clock #example_tick ins:nth-child(4) { transform: rotateZ(-30deg); } #example_clock #example_tick ins:nth-child(5) { transform: rotateZ(60deg); } #example_clock #example_tick ins:nth-child(6) { transform: rotateZ(-60deg); } /* 时针 */ #example_hour { width: 0.5em; height: 5.0em; border-radius: 0.5em / 7.5em 7.5em 0.5em 0.5em; background-color: #00f; position: absolute; bottom: 50%; left: 50%; margin: -0.5em 0 0 -.25em; transform-origin: bottom; } /* 分针 */ #example_minute { width: 0.4em; height: 6.0em; border-radius: 0.4em / 10.0em 10.0em 0.4em 0.4em; background-color: #0f0; position: absolute; bottom: 50%; left: 50%; margin: 0.2em 0 0 -0.2em; transform-origin: bottom; } /* 指针的轴 */ #example_dot { width: 1.0em; height: 1.0em; border-radius: 50%; background-color: rgba(10, 30, 105, .7); position: absolute; top: 50%; left: 50%; margin: -0.5em 0 0 -0.5em; } #example_dot::after { content: \"\"; display: block; width: 0.5em; height: 0.5em; border-radius: 50%; background-color: #f00; position: absolute; top: 50%; left: 50%; margin: -0.25em 0 0 -0.25em; } /* 秒针 */ #example_second { width: 0.2em; height: 10.0em; border-radius: 0.2em / 12.5em 12.5em 0.2em 0.2em; background-color: #f00; position: absolute; bottom: 50%; left: 50%; margin: -0.1em 0 0 -0.1em; transform-origin: bottom; } var colockTimer = null //计时器 var hourTick = document.querySelector('#example_hour')//时针 var minuteTick = document.querySelector('#example_minute')//分针 var secondTick = document.querySelector('#example_second')//秒针 var second = 0, minute = 0, hour = 0, sDeg = 0, mDeg = 0, hDeg = 0 clearInterval(colockTimer) colockTimer = setInterval(function () { var date = new Date() hour = date.getHours() minute = date.getMinutes() second = date.getSeconds() hDeg = (hour % 12 + minute / 60 + second / 3600) * 30 mDeg = (minute + second / 60) * 6 sDeg = second * 6 hourTick.style.transform = 'rotateZ('+ hDeg + 'deg)' minuteTick.style.transform = 'rotateZ('+ mDeg + 'deg)' secondTick.style.transform = 'rotateZ('+ sDeg + 'deg)' }, 100) css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/* 轮廓 */.clock { margin: 1.0em auto; width: 22.0em; height: 22.0em; position: relative; border: 1.0em solid rgba(0, 0, 0, 0.7); background-color: #fff; border-radius: 50%; box-shadow: 0 0 1.5em #333;}/* 12 个刻度 */.clock .tick ins { display: block; width: 19.8em; height: 0.3em; border-radius: 0.3em; background-image: linear-gradient(90deg, red 6%, transparent 6%, transparent 94%, red 94%, red 100%); position: absolute; top: 50%; left: 50%; margin: -0.15em 0 0 -9.9em;}.clock .tick ins:nth-child(n+3) { background-image: linear-gradient(90deg, grey 6%, transparent 6%, transparent 94%, grey 94%, grey 100%);}.clock .tick ins:first-child { transform: rotateZ(90deg);}.clock .tick ins:nth-child(3) { transform: rotateZ(30deg);}.clock .tick ins:nth-child(4) { transform: rotateZ(-30deg);}.clock .tick ins:nth-child(5) { transform: rotateZ(60deg);}.clock .tick ins:nth-child(6) { transform: rotateZ(-60deg);}/* 时针 */.hour { width: 0.5em; height: 5.0em; border-radius: 0.5em / 7.5em 7.5em 0.5em 0.5em; background-color: #00f; position: absolute; bottom: 50%; left: 50%; margin: -0.5em 0 0 -.25em; transform-origin: bottom;}/* 分针 */.minute { width: 0.4em; height: 6.0em; border-radius: 0.4em / 10.0em 10.0em 0.4em 0.4em; background-color: #0f0; position: absolute; bottom: 50%; left: 50%; margin: 0.2em 0 0 -0.2em; transform-origin: bottom;}/* 指针的轴 */.dot { width: 1.0em; height: 1.0em; border-radius: 50%; background-color: rgba(10, 30, 105, .7); position: absolute; top: 50%; left: 50%; margin: -0.5em 0 0 -0.5em;}.dot::after { content: \"\"; display: block; width: 0.5em; height: 0.5em; border-radius: 50%; background-color: #f00; position: absolute; top: 50%; left: 50%; margin: -0.25em 0 0 -0.25em;}/* 秒针 */.second { width: 0.2em; height: 10.0em; border-radius: 0.2em / 12.5em 12.5em 0.2em 0.2em; background-color: #f00; position: absolute; bottom: 50%; left: 50%; margin: -0.1em 0 0 -0.1em; transform-origin: bottom;} html1234567891011121314&lt;div class=\"clock\"&gt; &lt;div class=\"tick\"&gt; &lt;ins&gt;&lt;/ins&gt; &lt;ins&gt;&lt;/ins&gt; &lt;ins&gt;&lt;/ins&gt; &lt;ins&gt;&lt;/ins&gt; &lt;ins&gt;&lt;/ins&gt; &lt;ins&gt;&lt;/ins&gt; &lt;/div&gt; &lt;div class=\"hour\"&gt;&lt;/div&gt; &lt;div class=\"minute\"&gt;&lt;/div&gt; &lt;div class=\"dot\"&gt;&lt;/div&gt; &lt;div class=\"second\"&gt;&lt;/div&gt;&lt;/div&gt; js123456789101112131415161718var colockTimer = null //计时器var hourTick = document.querySelector('.hour')//时针var minuteTick = document.querySelector('.minute')//分针var secondTick = document.querySelector('.second')//秒针var second = 0, minute = 0, hour = 0, sDeg = 0, mDeg = 0, hDeg = 0clearInterval(colockTimer)colockTimer = setInterval(function () { var date = new Date() hour = date.getHours() minute = date.getMinutes() second = date.getSeconds() hDeg = (hour % 12 + minute / 60 + second / 3600) * 30 mDeg = (minute + second / 60) * 6 sDeg = second * 6 hourTick.style.transform = 'rotateZ('+ hDeg + 'deg)' minuteTick.style.transform = 'rotateZ('+ mDeg + 'deg)' secondTick.style.transform = 'rotateZ('+ sDeg + 'deg)'}, 100) — The End —","link":"/css/2017/11/11/"},{"title":"CSS3 文本","text":"CSS3 对文字的处理提供了阴影、溢出处理、换行处理 文字阴影text-shadow: h-shadow v-shadow blur color; 其中 h-shadow v-shadow 允许负值 文字阴影示例： .css3-text-shadow { text-shadow: 2px 1px 0px #ccc, 3px 2px 0 #666; font-size: 25px; } Text Shadow 实现代码： html1234567&lt;style&gt; .css3-text-shadow { text-shadow: 2px 1px 0px #ccc, 3px 2px 0 #666; font-size: 25px; }&lt;/style&gt;&lt;span class=\"css3-text-shadow\"&gt;Text Shadow&lt;/span&gt; IE9 不支持该特性 文字溢出text-overflow: ellipsis 溢出省略text-overflow: clip 溢出修剪 文字溢出后显示 … 该属需要配合 overflow: hidden; white-space: nowrap; 一起使用 .css3-text-overflow { width: 250px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; color: blue; } .css3-text-overflow:hover { white-space: normal; } This is long long long long long long text 实现代码： thml12345678910111213&lt;style&gt;.css3-text-overflow { width: 250px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; color: blue;}.css3-text-overflow:hover { white-space: normal;}&lt;/style&gt;&lt;p class=\"css3-text-overflow\"&gt;This is long long long long long long text&lt;/p&gt; 文字换行多行文本文字溢出处理，非标准属性，可应用于移动端 .css3-text-multiple-overflow { display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; width: 250px; overflow: hidden; text-overflow: ellipsis; color: blue; } This is long long long long long long text This is long long long long long long text This is long long long long long long text 实现代码： html123456789101112&lt;style&gt;.css3-text-multiple-overflow { display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; width: 250px; overflow: hidden; text-overflow: ellipsis; color: blue;}&lt;/style&gt;&lt;p class=\"css3-text-multiple-overflow\"&gt;This is long long long long long long text This is long long long long long long text This is long long long long long long text&lt;/p&gt; — The End —","link":"/css/2017/03/01/"},{"title":"CSS3 的选择器","text":"CSS3 的选择器比 CSS2 强大了很多 属性 E[attr] 表示存在 attr 属性即可； E[attr=val] 表示属性值完全等于 val E[attr~=val] 表示的一个单独的属性值 这个属性值是以空格分隔的 E[attr|=val] 表示的要么一个单独的属性值 要么这个属性值是以“-”分隔的 E[attr*=val] 表示的属性值里包含 val 字符并且在“任意”位置 E[attr^=val] 表示的属性值里包含 val 字符并且在“开始”位置 E[attr$=val] 表示的属性值里包含 val 字符并且在“结束”位置 ... 伪类 E:nth-child(n) 第 n 个子元素，计算方法是 E 元素的全部兄弟元素 E:nth-of-type(n) 第 n 个子元素，计算方法只是E元素，会忽略其子元素的存在 E:nth-last-child(n) 同 E:nth-child(n) 计算顺序相反。 E:nth-last-of-type(n) 同 E:nth-of-type(n) 计算顺序相反。 E:only-child 表示当前以 E 确定的父元素，除E之外并无其它子元素（独生子）； E:only-of-type 表示当前以E确定的父元素， 除 E 之外不能包含其它和 E 同类型的子元素； E:target 结合锚点进行使用，处于当前锚点的元素会被选中； E:empty 选中没有任何子节点的 E 元素； ... 关于n的取值范围：1、 遵循线性变化，其取值 1、2、3、4、…2、当 n 做为一个独立值时，n 取值为 n&gt;=1，例如 nth-child(n)3、当 n 做一个系数时，n 取值为 n&gt;=0 或者 n&lt;0，例如 nth-child(2n+1)、nth-child(-1n+5) 此处需要理解 2n+1 或者 -n+5 做为一个整体不能小于 1； 重点理解 E 是用来参考确定其父元素的，nth-child(n) 对应根据E元素确定的父元素的所有子元素，nth-of-type(n) 的不同之处在于其对应的是只有 E 元素，会忽略其子元素。 伪元素 E::selection 可改变选中文本的样式 E::placeholder 可改变 placeholder 默认样式，这个存在明显的兼容问题，比如 ::-webkit-input-placeholder，具体参考手册进行对比。 E::after、E::before ... “:” 与 “::” 区别在于区分伪类和伪元素E:after、E:before 在旧版本里是伪类，在新版本里是伪元素，新版本下 E:after、E:before 会被自动识别为 E::after、E::before — The End —","link":"/css/2017/02/27/"},{"title":"绚丽的 CSS3","text":"CSS3 扩展了 CSS2.1 ，CSS 变得更绚丽多彩了 👉选择器 属性 伪类 伪元素 👉颜色 rgba hsla 👉文本 文字阴影 文字溢出 文字换行 👉边框 边框阴影 边框圆角 边框图片 👉 背景图尺寸 背景裁切 背景定位参照点 多重背景 👉渐变 线性渐变 径向渐变 重复渐变 👉 主轴 侧轴 方向 👉 👉 帧动画 补间动画 贝塞尔曲线 👉 html 标签的形式 CSS 属性形式 👉 字体格式 字体图标 — The End —","link":"/css/2017/02/26/"},{"title":"CSS3 的颜色","text":"CSS3 新增了两种表示颜色的方式 CSS2 colorString使用英文颜色单词：red、green、blue、transparent（透明无色） 请看颜色实例 👉 color grid RGBRGB 即 Red、Green、Blue。 rgb(0, 0, 255) 蓝色。使用三组 10 进制数（0~255）表示。从左到右，每一组代表的颜色分别为 red、green、blue 。 也可以使用百分比，但要求三组都使用百分比：rbg(0%, 0%, 100%) 蓝色 HEX#ff0000 红色。使用三组、每组两位 16 进制数表示。每一组代表的颜色分别为 red、green、blue 。 三组中的每组两位相同可以简写：#f00 红色 CSS3 color新增了RGBA、HSLA 模式，其中的 A 表示透明度通道，即可以设置颜色值的透明度，相较 opacity，不具有继承性，即不会影响子元素的透明度。 RGBA在 rgb 的基础上添加了一位参数 (alpha) 表示 不透明度，范围是 0~1 。0 是完全透明，1 是完全不透明。 rgba(255, 0, 0, 0.5) 红色半透明 HSLAHSLA 和 PhotoShop 中的调色一样。 H：Hue(色调)。0(或360) 表示红色，120 表示绿色，240 表示蓝色，也可取其他数值来指定颜色。取值为 0~360 S：Saturation (饱和度)。取值为 0%~100% L：Lightness (亮度)。取值为 0%~100% A：Alpha 不透明度。取值为 0~1 之间。 — The End —","link":"/css/2017/02/28/"},{"title":"css 旋转 3D 立方体","text":"小技巧：使用 CSS3 一个酷炫的旋转立方体 /* 让立方体居中显示的容器，仅为了展示友好 */ .example-cubic-container { margin: 20px auto; text-align: center; font-size: 10px; } /* 设置立方体的面积，preserve-3d 开启 3d 视觉 */ .example-cubic { display: inline-block; position: relative; height: 10em; width: 10em; user-select: none; transition: transform 2s linear; transform-style: preserve-3d; animation: spinningH 6s infinite linear; } /* 暂替动画 */ .example-cubic:hover { animation-play-state: paused; } /* 设置绝对定位，使六个面先重叠在一起 */ .example-cubic > div { position: absolute; height: inherit; width: inherit; opacity: 0.8; text-align: center; } /* 定义六个面对旋转角度和位移，交换 rotate 和 translate 属性会得到不同的结果 */ .example-cubic > div:nth-child(1) { transform: translate3d(0, 0, 5em); background-color: pink; color: white; } .example-cubic > div:nth-child(2) { transform: rotate3d(0, 1, 0, 90deg) translate3d(0, 0, 5em); background-color: orange; color: lawngreen; } .example-cubic > div:nth-child(3) { transform: rotate3d(0, 1, 0, 180deg) translate3d(0, 0, 5em); background-color: white; color: pink; } .example-cubic > div:nth-child(4) { transform: rotate3d(0, 1, 0, -90deg) translate3d(0, 0, 5em); background-color: lawngreen; color: orange; } .example-cubic > div:nth-child(5) { transform: rotateX(-90deg) rotateZ(180deg) translate3d(0, 0, 5em); background-color: mediumpurple; color: lightskyblue; } .example-cubic > div:nth-child(6) { transform: rotate3d(1, 0, 0, 90deg) translate3d(0, 0, 5em); background-color: lightskyblue; color: mediumpurple; } /* 旋转动画 */ @keyframes spinningH { from { transform: rotateX(0deg) rotateY(0deg); } to { transform: rotateX(720deg) rotateY(360deg); } } html12345678910&lt;div class=\"container\"&gt; &lt;div class=\"cubic\"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* 让立方体居中显示的容器，仅为了展示友好 */.container { margin: 2.0em auto; text-align: center;}/* 设置立方体的面积，preserve-3d 开启 3d 视觉 */.cubic { display: inline-block; position: relative; height: 10em; width: 10em; user-select: none; transition: transform 2s linear; transform-style: preserve-3d; animation: spinningH 6s infinite linear;}/* 暂替动画 */.cubic:hover { animation-play-state: paused;}/* 设置绝对定位，使六个面先重叠在一起 */.cubic &gt; div { position: absolute; height: inherit; width: inherit; opacity: 0.8; text-align: center;}/* 定义六个面对旋转角度和位移，交换 rotate 和 translate 属性会得到不同的结果 */.cubic &gt; div:nth-child(1) { transform: translate3d(0, 0, 5em); background-color: pink; color: white;}.cubic &gt; div:nth-child(2) { transform: rotate3d(0, 1, 0, 90deg) translate3d(0, 0, 5em); background-color: orange; color: lawngreen;}.cubic &gt; div:nth-child(3) { transform: rotate3d(0, 1, 0, 180deg) translate3d(0, 0, 5em); background-color: white; color: pink;}.cubic &gt; div:nth-child(4) { transform: rotate3d(0, 1, 0, -90deg) translate3d(0, 0, 5em); background-color: lawngreen; color: orange;}.cubic &gt; div:nth-child(5) { transform: rotateX(-90deg) rotateZ(180deg) translate3d(0, 0, 5em); background-color: mediumpurple; color: lightskyblue;}.cubic &gt; div:nth-child(6) { transform: rotate3d(1, 0, 0, 90deg) translate3d(0, 0, 5em); background-color: lightskyblue; color: mediumpurple;}/* 旋转动画 */@keyframes spinningH { from { transform: rotateX(0deg) rotateY(0deg); } to { transform: rotateX(720deg) rotateY(360deg); }} — The End —","link":"/css/2017/11/04/"},{"title":"css 旋转环形 loadding 效果","text":"小技巧：使用 CSS3 一个酷炫的 loadding 效果 .example-loader-circle-container { text-align: center; font-size: 25px; } .example-loader { position: relative; display: inline-block; width: 5em; height: 5em; border-radius: 50%; border: 0.2em solid transparent; border-top-color: #ddd; animation: spin 2s linear infinite; z-index: 1001; } .example-loader::before { content: \"\"; position: absolute; top: 0.3em; left: 0.3em; right: 0.3em; bottom: 0.3em; border-radius: 50%; border: 0.2em solid transparent; border-top-color: #ddd; animation: spin 1.5s linear infinite; } .example-loader::after { content: \"\"; position: absolute; top: 0.8em; left: 0.8em; right: 0.8em; bottom: 0.8em; border-radius: 50%; border: 0.2em solid transparent; border-top-color: #ddd; animation: spin 3s linear infinite; } @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } } 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* 使 loader 居中 */.container { text-align: center; font-size: 25px;}/* 最内层的 1/4 环形 */.loader { position: relative; display: inline-block; width: 5em; height: 5em; border-radius: 50%; border: 0.2em solid transparent; border-top-color: #ddd; animation: spin 2s linear infinite; z-index: 1001;}/* 中间层的 1/4 环形 */.loader::before { content: \"\"; position: absolute; top: 0.3em; left: 0.3em; right: 0.3em; bottom: 0.3em; border-radius: 50%; border: 0.2em solid transparent; border-top-color: #ddd; animation: spin 1.5s linear infinite; }/* 最外层的 1/4 环形 */.loader::after { content: \"\"; position: absolute; top: 0.8em; left: 0.8em; right: 0.8em; bottom: 0.8em; border-radius: 50%; border: 0.2em solid transparent; border-top-color: #ddd; animation: spin 3s linear infinite; }/* 360°旋转动画 */@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); }} 123&lt;div class=\"container\"&gt; &lt;div class=\"loader\"&gt;&lt;/div&gt;&lt;/div&gt; — The End —","link":"/css/2017/10/21/"},{"title":"css 常见布局","text":"使用 css 实现两列、三列布局，水平居中、垂直居中的几种方式 两列布局html 代码1234&lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; flex 实现123456789.container { display: flex;}.left { width: 120px;}.right { flex: 1;} table 实现12345678910.container { display: table; width: 100%;}.left, .right { display: table-cell;}.left { width: 120px;} float 实现12345678910.left { float: left; width: 120px;}.right { /* overflow 非 visible 的值 */ overflow: hidden; /* or */ /* margin-left: 120px; */} 三列布局html 代码12345&lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; flex 实现123456789101112 .container { display: flex; }.left { width: 120px;}.center { flex: 1;}.right { width: 120px;} table 实现12345678910.container { display: table; width: 100%; }.left, .center, .right { display: table-cell;}.left, .right { width: 120px;} float 实现123456&lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;!-- center 放下面 --&gt; &lt;div class=\"center\"&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112.left { float: left; width: 120px;}.right { float: right; width: 120px;}.center { /* overflow 非 visible 的值 */ overflow: hidden;} 水平居中123&lt;div class=\"container\"&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt;&lt;/div&gt; text-align 实现1234567.container { text-align: center;}.inner { display: inline-block; /* or display: inline; */} table 实现1234.inner { display: table; margin: 0 auto;} margin 实现1234.inner { width: 100px; margin: 0 auto;} 水平 + 垂直 居中flex 实现12345.container { display: flex; justify-content: center; align-items: center;} position 实现IE7及之前版本不支持1234567891011.container { position: relative;}.inner { position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto;} orIE8及之前版本不支持123456789.container { position: relative;}.inner { position: absolute; top: 50%; left: 50%; transform: translate3d(-50%, -50%, 0);} or123456789101112.container { position: relative;}.inner { position: absolute; top: 50%; left: 50%; width: 100px; height: 100px; margin-top: -25px; margin-left: -25px;} table 实现123456789.container { display: table-cell; vertical-align: middle; text-align: center;}.inner { display: inline-block; /* or display: inline; */} line-height 实现123456789.container { height: 200px; line-height: 200px; text-align: center;}.inner { display: inline-block; /* or display: inline; */} button 元素实现123&lt;button class=\"container\"&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt;&lt;/button&gt; 1234.inner { display: inline; /* display: inline-block; */} — The End —","link":"/css/2017/10/28/"},{"title":"git 实践","text":"记录工作中使用 git 的一些实践经验 分支策略图解 git rabse -i 交互模式branch、 HEAD 参数解释git rebase -i 是对当前分支的 commit 进行操作。要求以参数 branch 或 HEAD 结尾 HEAD 参数结尾，就是对指定的 HEAD 之后的的（不包括 HEAD）的提交进行 rebase 操作 branch （分支名）参数结尾，就是指定某个分支作为参照，寻找与之最近的一次公有的 commit （不包括该 commit）之后的提交，进行 rebase 操作 修改历史提交git commit –amend 可以修改最后一次提交，但对于历史提交，要如何修改？ 比如你要修改 HEAD^^ 的提交 执行 rebase -i HEAD~3 进入 rebase 交互模式 把你要修改的 HEAD^^ 的 pick 改成 edit 或者 e ， wq 保存退出 用 git log 你发现那个 HEAD^^ 在第一个了。 这时你可以使用 git commit –amend 修改这个 commit。修改完后 git rebase –continue 就可以了。 提示被修改的 commit 节点之后的 commit 节点的 hash 都会变化！中途可以 git rebase –abrot 取消操作 合并提交多个历史提交比如合并最后 3 提交为一次提交 执行 git rebase -i HEAD~3 出现历史 commit 的列表，最下面的提交记录才最新的！ git 可以把后面新的提交压缩到之前的提交，只要把列表前的 pick 改成 s 或 squash。 上面的命令显示 3 条 commit ，我们把第二、三条 commit 的 pick 改成 s 。 输入 wq 指令保存后，会弹出编辑 message 的界面，可以为此次合并输入新的 message。默认使用第一、二、三条的 message 记录。 提醒只能把设为 squash 的 commit 合并到它前一个 commit，所以第一个 commit 不能设为 squash如果设置的 squash 不连续，会产生多个合并，并多次提示输入新的 message对本地版本库历史提交的修改导致与远程仓库版本不一致，需要强制 push ！合作开发的时候尤其需要注意，避免代码覆盖的情况！ 合并分支假设：现在有两个分支 master （稳定版）、hotfix (修补) 要求：在 hotfix 分支修复 bugs 后（已经累计多次 commit 记录），合并到 master 并发布新的稳定版 合并分支操作（merge）分两种情况：fast-forward (快进)、recursive (递归)。其中快进模式不会产生额外的 commmit，递归模式需要为本次合并创建一个 commit 下图分别是符合这两种情况的分支情况图示 fast-forward (快进) recursive (递归) 不管是快进模式还是递归模式，合并后 master 分支都会保留 hotfix 的历史提交记录。甚至还会多一个合并节点（递归模式）。但是大多数情况下，我们希望 master 分支到提交记录是清晰、干净的。每次合并只出现一个合并节点。如下图 如何实现？依次执行如下指令 12345678910# 切换到 master 分支git checkout master# 压缩 hotfix 分支的 commit，并合并到工作区git merge hotfix --squash# 查看工作区的状态，你可以看到工作区的变化git status# 手动执行 commit 操作，完成最终合并git commit -am 'merge hotfix into master: fixed xx xx x'# 合并后可删除 hotfix 分支git branch -d hotfix 这时 master 分支合并 hotfix 分支只有一个 commit （在建立 hotfix 分支后，master 又有提交记录，master 分支会保留这些提交记录，并处在合并节点之后） 由于在 hotfix 分支上的提交记录的用户，和管理 master 分支的用户不是一个用户。而这种合并操作最后一步需要手动 commit 并填写 message，这样就丢失了 hotfix 上的原始提交记录的 author time message 信息 所以第二种比较合理的合并方式是：先对 hotfix 进行变基，再并入 master 如何实现？依次执行如下指令 123456789101112# 切换到 hotfix 分支git checkout hotfix# 对照 master 分支进行变基，压缩所有历史提交到一个提交git rebase -i master# 变基完成后，查看当前 hotfix 分支相对 master 分支，你会发现 hotfix 分支只前进了一个 commit git log --oneline# 切换到 master 分支git checkout master# fast-forward 模式合并 hotfix 分支即可git merge hotfix# 合并后可删除 hotfix 分支git branch -d hotfix — The End —","link":"/git/2017/10/18/"},{"title":"git 常用命令","text":"Linux 之父 Linus 一直痛恨的 CVS 及 SVN 都是集中式的版本控制系统，用 C 写了一个分布式版本控制系统 Git，也是目前世界上最先进的分布式版本控制系统（没有之一）。它安全性高，可离线操作，并有强大的分支管理策略！git 是程序猿必备的技能之一。 以下简单总结了日常用到的一些 git 命令 先下载 git，安装成功后，打开 Git Bash，输入以下命令 configgit 配置分全局配置（带 –global 参数），项目配置 12345678# 显示是当前 git 配置git config --list# 编辑配置文件git config -e [--global]# 配置用户名git config [--global] user.name shinekidd# 配置邮箱git config [--global] user.email shinekidd@163.com clone12# 从服务器克隆仓库，可指定目标文件夹（folderName）git clone git@github.com:ShineKidd/example.git folderName add12345678910# 工作区的状态于暂存区状态保持一致，add之前 head 和暂存区是状态是一致的git add . git add --allgit add -A# 添加被追踪文件的修改改到暂存区git add -u# 添加指定文件或目录，支持通配符git add fileName *.js# 强制添加 .gitignore 忽略的文件git add -f fileName commit123456# 提交并填写提交日志，不使用 -m 参数可进入 vim 编辑器书写提交日志git commit -m 'fix #issue #48'# 修订最后一次提交，进入 vim 编辑 message 。会改变 head，合并冲突的时候不可用git commit --amend# 添加 tracked 的文件到暂存区，并提交已修改的文件git commit -a -m 'message' remote123456789101112# 添加该远程地址，保存别名为 origingit remote add origin git@github.com:ShineKidd/example.git# 更换仓库地址git remote set-url origin git@github.com:ShineKidd/test.git# 删除别名为 origin 的远程地址git remote rm origin# 查看已添加的远程地址git remote -v# 显示远程与本地分支细节对比git remote show origin# 移除远程冗余分支git remote prune origin branch-name fetch12# 拉取远程仓库到本地git fetch origin pull12345678# 接拉取远程分支，并入当前分支（前提：远程仓库分支与本地分支已建立联系）git pull # 同 git fetch + git merge# 拉取远程 dev 分支并与本地 dev 分支合并，同上两句命令git pull origin dev # 拉取远程 dev 分支与本地 master 分支合并git pull origin dev:master # 拉去远程分支，并入本地分支，并整理git pull --rebase # 同 git fetch + git rebase branch1234567891011121314# 新键分支git branch new-branch-name# 删除分支git branch -d branch-name# 基于当前分支的某个节点，创建新的分支git branch branch-name a8c1fe47# 强制删除分支git branch -D branch-name# 查看分支信息，默认显示本地分支，参数 -v -vv 显示最后提交信息，参数 -r 显示远程分支，参数 -a 显示所有分支git branch [-v][-r][-vv][-a]# 使用 git 在本地新建一个分支 debug 后，需要指定远程 origin/debug 分支与本地 debug 的联系git branch --set-upstream-to=origin/debug debug # 或者git branch --set-upstream debug origin/debug merge12345678910# 将 debug 并入当前分支，默认是 fast-forward (快进模式)，会保留所有提交记录git merge debug# 将远程仓库 origin 上的 dev 分支并入当前分支，一般在执行 fetch 操作后git merge origin/dev# 禁用 fast-forward 模式合并，合并后保留合并分支合并细节，但是要求输入合并日志，不输入会使用默认日志git merge debug --no-ff -m 'merged fix issue #455'# 把 debug 的 commit 合并到当前分支的工作区，这需要手动在 commit 一次，合并只产生一个 commitgit merge --squash debug# 如果发现冲突，取消合并操作git merge --abort tag12345678910# 查看所有 taggit tag# 在当前的 commit 上添加标签 v1.2git tag v1.2# 指定 commit 上添加标签 v1.1git tag v1.1 5fe47d89a# 指定 commit 上添加标签 v1.3，并附标签说明git tag -a v1.3 -m '新增了xxx功能' 8feb8b26f# 删除 v1.2 这个本地标签，删除线上见 git pushgit tag -d v1.2 push123456789101112# 第一次推送本地分 dev 分支到远程服务器git push -u origin dev# 之后的推送， Git Bash 直接 git push 就可以推送的对应的分支，在 cmd 中，要带 origin dev 参数git push# 推送 v1.2 这个标签到远程仓库git push origin v1.2# 推送所有的本地标签到远程仓库git push origin --tags# 同步本地已删除的标签 v1.2 到远程仓库git push origin :refs/tags/v1.2# 删除远程分支git push origin -d branch-name stash当你在开发新功能的时候，突然有一个紧急 bug 要修复怎么办？12345678910# 保存工作现场，这时工作区是 clean 的git stash# 查看保存的列表git stash list# 恢复某个记录到工作区git apply stash@{0} # 应用并删除最近的一次 stashgit stash pop # 删除某个 stashgit stash drop stash@{0} status1git status diff如果用 vscode 编辑器，推荐一款 git 插件 Git History Diff，非常方便查看提交历史1234567891011121314# 比较暂存区与当前工作区文件的区别git diff# 比较指定提交与当前工作区的区别git diff eb667b8# 比较两处提交的差异git diff head^ head# 比较指定提交中的某个文件与当前工作区的区别git diff eb667b8 -- ./src/fileName # 比较暂存区与最新本地版本库（本地库中最近一次commit的内容）git diff --cached# 比较暂存区与本地版本库指定提交的区别git diff --cached eb667b8# 比较 dev 分支的指定提交与当前工作区的区别git diff dev eb667b8 resetHEAD 指针默认指向最近的一次 commit，通过 reset 操作可以改变 HEAD 指针指向的 commit。git reset 默认参数是 –mixed，默认 commit 是 head 12345678# 同 git reset --mixed head ，暂存区和最近一次 commit(head) 保持一致，即会放弃之前的 git add 操作，工作区不受影响git reset# 工作区和暂存区不受影响，只是 HEAD 指针指向特定的 commit 了git reset --soft eb667b8# 工作区和暂存区和指定 commit 保持一致，工作区未保存将会被覆盖，变成 clean 的状态，这是个危险的操作git reset --hard eb667b8# 重置 HEAD 到指定提交，不改变工作区和暂存区的状态git reset --keep eb667b8 revert12# 撤销指定提交git revert 785cda4 checkout12345678910111213141516# 切换当前分支为 debug 分支git checkout debug# 新键并切换分支git checkout -b new-branch# 基于当前的分支，创建一个没有提交记录的新分支git checkout --orphan new-branch# 切换分支，并把当前分支修改的内容转移到目标分支git checkout --merge branch-name# 从暂存区检出文件，工作区的文件会被检出文件覆盖，可以用 . 表示所有文件git checkout -- fileName# # 检出某个 commit 中的文件，工作区的文件会被检出文件覆盖，可以用 . 表示所有文件git checkout eb667b8 -- fileName# 检出某个 commit ，如果你的工作区有变更未提交，操 aborgit checkout eb667b8# 强制检出某 commit，会丢失工作区的修改，危险操作git checkout -f eb667b8 rm123456# 删除工作区区文件，该命令会把操作提交到暂存区git rm fileName # 文件已添加到暂存区，删除工作区区文件git rm -f fileName# 删除暂存区文件，并不再追踪文件的变化(文件状态变成 untracked)git rm --cached fileName log123456789101112131415161718192021222324252627282930# 显示前 n 条git log -n# 按 commit 显示前后两个 commit 间的差异，显示提交历史及文件改动git log -p [commit]# --graph 以图形画的形式显示 git log --graph # 显示每次更新的修改文件的统计信息，每个提交都列出了修改过的文件，以及其中添加和移除的行数git log --stat# 一行显示，只显示哈希值和提交说明git log --oneline # 只显示 --stat 中最后的行数添加修改删除统计git log --shortstat# 尽在已修改的提交信息后显示文件清单git log --name-only# 显示新增、修改和删除的文件清单git log --name-status# 仅显示SHA-1的前几个字符，而非所有的40个字符git log --abbrev-commit# 过滤提交说明关键字git log --grep=\"fix\"# 过滤 merge commitgit log --no-merges# 只显示 merge commitgit log --merges# 格式显示历史提交信息git log --pretty=[oneline,short,medium,full,fuller,email,raw,format]# 显示用户提交次数，按提交次数排序git shortlog -sn# 查看输入过的 git 指令，在挽救错误方面很有用git reflog show123456# 查看 v1.2 这个标签的信息git show v1.2# 显示某次提交的内容差异git show head^# 显示某次提交的某文件的的内容差异git show head -- file rebaserebase 操作可以把本地未 push 的分叉提交历史整理成直线, rebase 的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比 12345678910# 把 debug 分支并入当前分支，并整理git rebase debug# 编辑未完成的 rebase 操作git rebase --edit-to# 变基过程遇到冲突，添加到暂存区后继续执行git rebase --continue# 取消变基操作git rebase --abort# rebase 交互模式git rebase -i [branch | HEAD] check-ignore1git check-ignore -v fileName — The End —","link":"/git/2017/10/14/"},{"title":"git commit message 的格式规范","text":"格式化的 Commit message，不但方便快速浏览，查找历史提交信息，还可以直接从 commit 生成 Change log。 本文内容摘自 Commit message 和 Change log 编写指南 每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。 &lt;type>(&lt;scope>): &lt;subject> // 空一行 &lt;body> // 空一行 &lt;footer> 其中，Header 是必需的，Body 和 Footer 可以省略。 不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。 HeaderHeader 部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。 type 用于说明 commit 的类别，只允许使用下面7个标识。 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 cope 用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 subject 是 commit 目的的简短描述，不超过50个字符。 bodyBody 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。 More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. Further paragraphs come after blank lines. - Bullet points are okay, too - Use a hanging indent 有两个注意点。 使用第一人称现在时，比如使用 change 而不是 changed 或 changes。 应该说明代码变动的动机，以及与以前行为的对比。 FooterFooter 部分只用 于两种情况。 不兼容变动 如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。 BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: { myAttr: 'attribute', } After: scope: { myAttr: '@', } The removed `inject` wasn't generaly useful for directives so there should be no code using it. 关闭 Issue 如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。 Closes #234 也可以一次关闭多个 issue 。 Closes #123, #245, #992 Revert还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。 revert: feat(pencil): add 'graphiteWidth' option This reverts commit 667ecc1654a317a13331b17617d973392f415f02. Body部分的格式是固定的，必须写成 This reverts commit . 其中的 hash 是被撤销 commit 的 SHA 标识符。 如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的 Reverts 小标题下面。 — The End —","link":"/git/2017/10/16/"},{"title":"chrome 的快捷键","text":"Google chrome 是最受程序员喜爱的浏览器（没有之一），它 UI 简洁大方，网页性能十分出色，调试功能十分强大，插件非常丰富！还支持一大波 快捷键！ 地址栏 功能 按键 切换到地址栏并选中 URL Ctrl + l 或 Alt + d 或 F6 切换到地址栏搜索关键字 Ctrl + k 或 Ctrl + e 在新标签打开地址栏的输入 Alt + Enter 在输入的地址前后补全 www .com Ctrl + Enter 搜索指定网站 输入网站域名后 Tab 键，在输入关键字进行搜索 鼠标 功能 按键 拖动链接、标签到收藏、chrome 窗口 按下 MouseLeft 拖动 点击在新窗口打开链接 Ctrl + MouseLeft 点击在新标签打开链接 Ctrl + MouseLeft 点击在新标签打开链接并跳转到该链接 Ctrl + Shift + MouseLeft 点击下载链接内容 Alt + MouseLeft 缩放网页 Ctrl + MouseWheel 水平滚动 Shift + MouseWheel 网页 功能 按键 显示当前网页的 HTML 源代码 Ctrl + u 收藏当前网页 Ctrl + d 收藏打开的所有标签页 Ctrl + Shift + d 向下翻页 Space 向上翻页 Shift + Space 放大网页 Ctrl + + 缩小网页 Ctrl + - 默认缩放 Ctrl + 0 停止加载网页 Esc 打印 Ctrl + p 标签页 功能 按键 打开新标签 Ctrl + t 打开主页 Alt + Home 重新打开最后关闭的标签 Ctrl + Shift + t 关闭当前标签 Ctrl + w 或 Ctrl + F4 关闭所有标签 Ctrl + Shift + w 前进浏览记录 Alt + ← 后退浏览记录 Alt + → 跳转到下一个打开的标签页 Ctrl + Tab 跳转到上一个打开的标签页 Ctrl + Shift + Tab Ctrl + 9 跳转到最后一个标签页 Ctrl + 1 到 Ctrl + 8 跳转到特定标签页 窗口 功能 按键 打开新窗口 Ctrl + n 打开隐身窗口 Ctrl + Shift + n 最大化 chrome Ctrl + Space + x 最小化 chrome Ctrl + Space + n 退出浏览器 Ctrl + Shift + q 功能 功能 按键 打开历史记录 Ctrl + h 打开下载内容 Ctrl + j 打开任务管理器 Shift + Esc 打开清除数据选项 Ctrl + Shift + Delete 打开文件 Ctrl + o 打开书签管理器 Ctrl + Shift + o 切换显示书签栏 Ctrl + Shift + b 查找 Ctrl + f 跳到下一个查找 Ctrl + g 跳到上一个查找 Ctrl + Shift + g 调试 功能 按键 打开调试 Ctrl + Shift + j 或 Ctrl + Shift + i 切换到设备模式 Ctrl + Shift + m 切换检查元素模式 Ctrl + Shift + c 搜索源文件 Ctrl + o — The End —","link":"/hotkey/2017/10/07/"},{"title":"vscode 编辑器的快捷键","text":"微软的 Visual Studio Code 已成为最流行的编辑器（应该没有之一），掌握它的一些常用的快捷可以让你的工作效率提高 20% 左右 打开 功能 按键 打开文件 Ctrl + o 打开文件夹 Ctrl + k + o 打开最近的文件 ctr + r 打开文件预览 Ctrl + k + v 打开设置 Ctrl + , 打开新的终端 Ctrl + Shift + ` 打开新的标签 Ctrl + n 打开新的编辑器 Ctrl + Shift + n 打开命令输入窗口 ctlr + Shift + p 在当前工作区打开 cmd Ctrl + Shift + c 查找 功能 按键 选中文字后进行查找 Ctrl + f 选中文字后进行全局查找 Ctrl + Shift + f 再切换区分大小写 Alt + c 再切换全字匹配 Alt + w 再切换正则匹配模式 Alt + r 聚焦下一个搜索结果 F3 聚焦上一个搜索结果 Shift + F3 替换 功能 按键 选中文字后进行查找并替换 Ctrl + h 选中文字后进行全局查找并替换 Ctrl + Shift + h 再全部替换 Ctrl + Alt + Enter 注释 功能 按键 文本或聚焦行切换单行注释 Ctrl + / 文本或聚焦行切换多行注释 Shift + Alt + a 选中文本或聚焦行可解除行注释 Ctrl + k + u 折叠所有块注释 Ctrl + k + / 选中 功能 按键 快速选中连续文本 双击鼠标左键 快速选中段落 三击鼠标左键 选中光标后的连续文本 Ctrl + Shift + → 选中光标前的连续文本 Ctrl + Shift + ← 选中光标后的所有文本 Ctrl + Shift + End 选中光标前的所有文本 Ctrl + Shift + Home 选中相同的文本 Ctrl + d 再跳过当前选中文本继续 Ctrl + k + d 缩进 功能 按键 增大光标所在行缩进 Ctrl + [ 减少光标所在行缩进 Ctrl + ] 减少光标所在行缩进 Shift + Tab 编辑 功能 按键 撤销编辑 Ctrl + z 重做编辑 Ctrl + Shift + z 触发输入建议 Ctrl + Space 触发参数提示 Ctrl + Shift + Space 上下移动行 光标定位或选中所在行后 Alt + ↑ ↓ 删除 功能 按键 删除光标左侧的连续字符 Ctrl + Backspace 删除光标右侧的连续字符 Ctrl + Delete 删除光标所在行 Ctrl + Shift + k 删除行末尾空格 Ctrl + k + x 光标定位 功能 按键 定位到行首 Home 定位到行尾 End 定位到文档首 Ctrl + Home 定位到文档尾 Ctrl + End 移动光标到连续文本左侧 Ctrl + ← 移动光标到连续文本右侧 Ctrl + → 在光标上面插入行 Ctrl + Shift + Enter 在光标下面插入行 Ctrl + Enter 连续插入多行光标 按住鼠标中键垂直拖动或 连续插入多行光标 Shift + Alt + 鼠标左键垂直拖动 连续插入多行光标 Ctrl + Alt + ↑ ↓ 自定义插入多行光标 按住 Alt 键，点击鼠标左键 面板操做 功能 按键 切换显示面板 Ctrl + j 切换至”问题”Tab Ctrl + Shift + m 切换至”输出”Tab Ctrl + Shift + u 切换至”调试控制台”Tab Ctrl + Shift + v 切换显示”终端” Ctrl + ` 放大视图 Ctrl + = 缩小视图 Ctrl + - 切换拆分的编辑器 Ctrl + k + ←→↑↓ 打开最近文件 Ctrl + r 打开的标签 功能 按键 关闭当前标签 Ctrl + w 打开最近关闭的一个标签 Ctrl + Shift + t 关闭所有标签 Ctrl + k + w 保存所有标签的更改 Ctrl + k + s 关闭所有已保存的标签 Ctrl + k + u 关闭当前编辑器 Ctrl + Shift + w 切换标签 Ctrl + Tab 水平拆分编辑器 Ctrl + \\ 垂直拆分编辑器 Ctrl + k + \\ 当前标签移动到右侧编辑器 Ctrl + Alt + → 当前标签移动到左侧编辑器 Ctrl + Alt + ← 左侧功能菜单 功能 按键 切换显示侧边栏 Ctrl + b 切换到资源管理 Ctrl + Shift + e 切换到全局搜索 Ctrl + Shift + f 切换到源代码管理 Ctrl + Shift + g 切换到 debug Ctrl + Shift + d 切换到扩展 Ctrl + Shift + x 格式化 功能 按键 格式化当前文件 Shift + Alt + f 格式化选中代码块 Ctrl + k + f 切换换行显示 Alt + a 折叠展开 功能 按键 折叠光标所在区 Ctrl + Shift + [ 展开光标所在区 Ctrl + Shift + ] 全部折叠 Ctrl + k + 0 全部展开 Ctrl + k + j 折叠所有块注释 Ctrl + k + / — The End —","link":"/hotkey/2017/09/30/"},{"title":"HTML中的 a 标签","text":"&lt;a&gt; 元素。标签定义超链接，用于从一张页面链接到另一张页面。还有其他一些功能，看看 &lt;a&gt; 有哪些属性和功能。 href用 href 属性指定要跳转的链接 url，没有 href 属性时，a 解析成和 span 一样 1234567891011121314151617181920&lt;!-- 常用 --&gt;&lt;a href=\"https://www.baidu.com\"&gt;跳转至百度&lt;/a&gt;&lt;!-- 锚点 --&gt;&lt;a href=\"#id\"&gt;页面滚动到指定 id 的 dom，没有 id 滚动到页面顶部&lt;/a&gt;&lt;!-- 发邮件 --&gt;&lt;a href=\"mailto:shinekidd@163.com\"&gt;发邮件给我&lt;/a&gt;&lt;!-- 打电话 --&gt;&lt;a href=\"tel:10010\"&gt;调出手机拨号界面&lt;/a&gt;&lt;!-- 发短信 --&gt;&lt;a href=\"sms:10010\"&gt;调出手机短信界面&lt;/a&gt;&lt;!-- 伪协议 --&gt;&lt;a href=\"javascript:alert(1)\"&gt;通过 URL 执行 javascript&lt;/a&gt;&lt;!-- 刷新页面 --&gt;&lt;a href=\"\"&gt;点击刷新当前页面&lt;/a&gt; target指定链接打开的的方式 123456789101112&lt;!-- 在新标签中打开 --&gt;&lt;a href=\"https://www.baidu.com\" target=\"_blank\"&gt;在新标签中打开&lt;/a&gt;&lt;!-- 在新标签中打开 --&gt;&lt;a href=\"https://www.baidu.com\" target=\"_self\"&gt;当前标签打开&lt;/a&gt;&lt;!-- 在指定的 iframe 中打开--&gt;&lt;a href=\"https://www.baidu.com\" target=\"baidu\"&gt;在新标签中打开&lt;/a&gt;&lt;iframe name=\"baidu\" width=\"300px\" height=\"500px\"&gt;&lt;/iframe&gt;&lt;a href=\"https://www.baidu.com\" target=\"_parent\"&gt;在父框架集中打开被链接文档&lt;/a&gt;&lt;a href=\"https://www.baidu.com\" target=\"_top\"&gt;在整个窗口中打开被链接文档&lt;/a&gt; 注意：用 button 包裹 a 后，在 FireFox 和 IE 下 会打不开链接！ download H512&lt;!-- 指定下载文件的文件名 --&gt;&lt;a href=\"https://www.kugou.com/deuisdh.mp3\" download=\"海阔天空.mp3\"&gt;下载海阔天空&lt;/a&gt; type H512&lt;!-- 规定被链接文档的的 MIME 类型 --&gt;&lt;a href=\"https://www.kugou.com/deuisdh.mp3\" type=\"audio/mpeg\"&gt;下载海阔天空&lt;/a&gt; — The End —","link":"/html/2017/02/25/"},{"title":"HTML 中常用的字符实体及编号对照表","text":"符实体及编号在 html markdown 中很有用，解析引擎会把它们直接按 普通的 字符串显示 显示结果 描述 实体名称 实体编号 空格 &nbsp;   或   &lt; 小于号 &lt; < &gt; 大于号 &gt; > &amp; 和号 &amp; & “ 引号 &quot; \" ‘ 撇号 &apos; (IE不支持) ' ￠ 分（cent） &cent; ¢ £ 镑（pound） &pound; £ ¥ 元（yen） &yen; ¥ € 欧元（euro） &euro; € § 小节 &sect; § © 版权（copyright） &copy; © ® 注册商标 &reg; ® ™ 商标 &trade; ™ × 乘号 &times; × ÷ 除号 &divide; ÷ 注释实体名称对大小写敏感！ 获取字符的编码的方法 1'&lt;'.charCodeAt(0) // 60 即 &lt; 的实体编号是 &amp;#60 更多请看 手册 — The End —","link":"/html/2017/02/13/"},{"title":"html5 新增的多媒体特性","text":"HTML 4.01 img 标签实现的图片的展示，对于视频，音频，则使用 object 标签引入 swf 控件才能实现，html5 提供原生标签实现了多媒体功能 audio不同浏览器支持格式不一样 123456&lt;audio controls=\"controls\"&gt; &lt;source src=\"audio/taste_song.mp3\" type=\"audio/mpeg\" /&gt; &lt;source src=\"audio/taste_song.ogg\" type=\"audio/ogg\" /&gt; &lt;!-- 当浏览器不兼容 audio 标签，就会将他以 div 方式解析 --&gt; 您的浏览器不支持 audio 标签。&lt;/audio&gt; video不同浏览器支持格式不一样 123456&lt;video controls=\"controls\" preload autoplay loop muted poster=\"\" height width&gt; &lt;source src=\"fun.ogg\" type=\"video/ogg\" /&gt; &lt;source src=\"fun.mp4\" type=\"video/mp4\" /&gt; &lt;!-- 当浏览器不兼容 video 标签，就会将他以 div 方式解析 --&gt; 你的浏览器不支持 video ！&lt;/video&gt; audio video 都有如下属性，不同浏览器支持的媒体格式不同，一般使用 source 指定多个源来处理兼容 属性 值 描述 autoplay autoplay 如果出现该属性，则音频在就绪后马上播放。 controls controls 如果出现该属性，则向用户显示控件，比如播放按钮。 loop loop 如果出现该属性，则每当音频结束时重新开始播放。 preload preload 如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。 src url 要播放的音频的 URL。 video 还支持 width height poster (海报) 属性 媒介事件由视频、图像以及音频等媒介触发的事件。适用于所有 HTML 5 元素，不过在媒介元素（诸如 audio、embed、img、object 以及 video）中最常用： 属性 值 描述 onabort script 当发生中止事件时运行脚本 oncanplay script 当媒介能够开始播放但可能因缓冲而需要停止时运行脚本 oncanplaythrough script 当媒介能够无需因缓冲而停止即可播放至结尾时运行脚本 ondurationchange script 当媒介长度改变时运行脚本 onemptied script 当媒介资源元素突然为空时（网络错误、加载错误等）运行脚本 onended script 当媒介已抵达结尾时运行脚本 onerror script 当在元素加载期间发生错误时运行脚本 onloadeddata script 当加载媒介数据时运行脚本 onloadedmetadata script 当媒介元素的持续时间以及其他媒介数据已加载时运行脚本 onloadstart script 当浏览器开始加载媒介数据时运行脚本 onpause script 当媒介数据暂停时运行脚本 onplay script 当媒介数据将要开始播放时运行脚本 onplaying script 当媒介数据已开始播放时运行脚本 onprogress script 当浏览器正在取媒介数据时运行脚本 onratechange script 当媒介数据的播放速率改变时运行脚本 onreadystatechange script 当就绪状态（ready-state）改变时运行脚本 onseeked script 当媒介元素的定位属性 [1] 不再为真且定位已结束时运行脚本 onseeking script 当媒介元素的定位属性为真且定位已开始时运行脚本 onstalled script 当取回媒介数据过程中（延迟）存在错误时运行脚本 onsuspend script 当浏览器已在取媒介数据但在取回整个媒介文件之前停止时运行脚本 ontimeupdate script 当媒介改变其播放位置时运行脚本 onvolumechange script 当媒介改变音量亦或当音量被设置为静音时运行脚本 onwaiting script 当媒介已停止播放但打算继续播放时运行脚本 当前，video 元素支持三种视频格式： 格式 IE Firefox Opera Chrome Safari Ogg No 3.5+ 10.5+ 5.0+ No MPEG 4 9.0+ No No 5.0+ 3.0+ WebM No 4.0+ 10.6+ 6.0+ No Ogg: 带有 Theora 视频编码和 Vorbis 音频编码的 Ogg 文件 MPEG4: 带有 H.264 视频编码和 AAC 音频编码的 MPEG 4 文件 WebM: 带有 VP8 视频编码和 Vorbis 音频编码的 WebM 文件 track为诸如 video 元素之类的媒介规定外部文本轨道。用于规定字幕文件或其他包含文本的文件，当媒介播放时，这些文件是可见的。 123456&lt;video width=\"320\" height=\"240\" controls=\"controls\"&gt; &lt;source src=\"forrest_gump.mp4\" type=\"video/mp4\" /&gt; &lt;source src=\"forrest_gump.ogg\" type=\"video/ogg\" /&gt; &lt;track kind=\"subtitles\" src=\"subs_chi.srt\" srclang=\"zh\" label=\"Chinese\"&gt; &lt;track kind=\"subtitles\" src=\"subs_eng.srt\" srclang=\"en\" label=\"English\"&gt;&lt;/video&gt; 目前所有主流浏览器都不支持 标签，edge safari 高版本支持 — The End —","link":"/html/2017/02/22/"},{"title":"html5 元素新增了一些新的属性","text":"HTML5 提供了一些新的标签的同时，也新增了些新的属性，以下是部分属性。 链接关系 rel指定链接与当前文档的关系，便于机器理解文档结构 1234567891011&lt;link rel=\"stylesheet\" href=\"style.css\"&gt;&lt;link rel=\"alternate\" type=\"application/rss+xml\" href=\"http://myblog.com/feed\"&gt;&lt;link rel=\"shortcut icon\" href=\"favicon.ico\"&gt;&lt;link rel=\"pingback\" href=\"http://myblog.com/xmlrpc.php\"&gt;&lt;link rel=\"prefetch\" href=\"http://myblog.com/main.php\"&gt;&lt;a rel=\"archives\" href=\"http://myblog.com/archives\"&gt;old posts&lt;/a&gt;&lt;a rel=\"external\" href=\"http://notmysite.com\"&gt;tutorial&lt;/a&gt;&lt;a rel=\"license\" href=\"http://www.apache.org/licenses/LICENSE-2.0\"&gt;license&lt;/a&gt;&lt;a rel=\"nofollow\" href=\"http://notmysite.com/sample\"&gt;wannabe&lt;/a&gt;&lt;a rel=\"tag\" href=\"http://myblog.com/category/games\"&gt;games posts&lt;/a&gt; 属性值 描述 alternate 文档的可选版本（例如打印页、翻译页或镜像） appendix 文档附录 bookmark 相关文档 copyright 包含版权信息的文档 chapter 文档的章 contents 文档目录 friend 友情链接 glossary 文档中所用字词的术语表或解释 help 帮助文档 index 文档索引 licence 一般用于文献，表示许可证的含义 nofollow 用于指定 Google 搜索引擎不要跟踪链接 next 集合中的下一个文档 prev 集合中的前一个文档 stylesheet 文档的外部样式表 start 集合中的第一个文档 section 文档的节 subsection 文档的子段 tag 标签集合 结构数据标记支持不好 12345678&lt;div itemscope itemtype=\"http://example.com/hello\"&gt; &lt;p&gt;我是&lt;span itemprop=\"博主\"&gt;ShineKidd&lt;/span&gt;。&lt;/p&gt; &lt;p&gt; 来自 &lt;span itemprop=\"国家\"&gt;太阳系&lt;/span&gt;的 &lt;span itemprop=\"地区\"&gt;地球&lt;/span&gt;生物。 &lt;/p&gt;&lt;/div&gt; 无障碍富互联网应用程序 （ARIA）主要针对于屏幕阅读设备(e.g. NVDA)，更快更好地理解网页 ，不仅仅是为了盲人用户，更多语义化 bootstrapt 1234567891011121314151617&lt;nav aria-label=\"Page navigation\"&gt; &lt;ul class=\"pagination\"&gt; &lt;li&gt; &lt;a href=\"#\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=\"#\" aria-label=\"Next\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 自定义属性 data通过DOM存储与DOM对象强相关的数据 12345&lt;p data-sex=\"male\" data-user-name=\"shinekidd\"&gt;ShineKidd&lt;p&gt;&lt;script&gt; document.querySelector('p').dataset // DOMStringMap {sex: \"male\", userName: \"shinekidd\"} document.querySelector('p').dataset.userName // \"shinekidd\"&lt;/script&gt; 从 dataset 中取出来的数据都是字符串书写时大小写不敏感data- 后面如有连字符 - 转成小驼峰 智能表单移动端系统根据 type 类型，适配不同的键盘。表单提交时，浏览器会根据 type required pattern max min maxlength minlength 等属性做简单的表单校验 1234567891011121314&lt;input type=\"text\" required&gt;&lt;input type=\"email\" value=\"some@email.com\"&gt;&lt;input type=\"date\" min=\"2010-08-14\" max=\"2011-08-14\" value=\"2010-08-14\"&gt;&lt;input type=week&gt;&lt;input type=time&gt;&lt;input type=datetime&gt; &lt;input type=datetime-local&gt;&lt;input type=month&gt;&lt;input type=\"range\" min=\"0\" max=\"50\" value=\"10\"&gt;&lt;input type=\"search\" results=\"10\" placeholder=\"Search...\"&gt;&lt;input type=\"tel\" placeholder=\"(555) 555-5555\" pattern=\"^\\(?\\d{3}\\)?[-\\s]\\d{3}[-\\s]\\d{4}.*?$\"&gt;&lt;input type=\"color\" placeholder=\"e.g. #bbbbbb\"&gt;&lt;input type=\"number\" step=\"1\" min=\"-5\" max=\"10\" value=\"0\"&gt;&lt;input type=\"url\" placeholder=\"e.g. http://t.cn/w\"&gt; — The End —","link":"/html/2017/02/18/"},{"title":"HTML中的 form 标签","text":"虽然 ajax 提交表单逐渐成为了主流，但 form 具有兼容性好，实现成本低的优点。 属性action表单内容提交的地址(接口)，在 ios 系统上，&lt;input type=&quot;search&quot;&gt; 键盘没有出现“搜索”按钮，就是 from 元素没有这个属性。 123&lt;form action=\"aip.example.com/s\"&gt; &lt;input type=\"search\" name=\"keyword\"&gt;&lt;/form&gt; method提交提交表单的 HTTP 请求方式，可选值 GET 、POST ，默认是 GET。GET 请求的速度快，参数附在请求的 URL 上，由于 URL 长度限制(约 2KB)，不能提交大量数据，此时使用 POST。 123&lt;form action=\"aip.example.com/s\" method=\"GET\"&gt; &lt;input type=\"search\" name=\"keyword\"&gt;&lt;/form&gt; enctype规定被提交数据的编码 值 描述 application/x-www-form-urlencoded 默认。在发送前对所有字符进行编码（将空格转换为 “+” 符号，特殊字符转换为 ASCII HEX 值）。 multipart/form-data 不对字符编码。当使用有文件上传控件的表单时，该值是必需的。 text/plain 将空格转换为 “+” 符号，但不编码特殊字符。 上传文件时，必须使用 multipart/form-data ，浏览器会把表单以控件为单位分割（分割符 boundary），并且为每个部分加 上Content-Dispositon: form-data; name=”attachment” 这类信息。 123&lt;form action=\"aip.example.com/upload\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"attachment\"&gt;&lt;/form&gt; name用于表单识别，可以使用 document.forms.formName 选中表单 DOM 123&lt;form action=\"aip.example.com/upload\" method=\"POST\" enctype=\"multipart/form-data\" name=\"upload\"&gt; &lt;input type=\"file\" name=\"attachment\"&gt;&lt;/form&gt; novalidate H5html5 的新曾属性，规定浏览器不校验表单。浏览器主动对某些 type 属性的 input 进行校验，并显示校验提示，而提示的样式并不符合产品设计，所以一般不使用浏览器默认校验。 1234&lt;form action=\"aip.example.com/s\" method=\"POST\" name=\"login\" novalidate=\"novalidate\"&gt; &lt;input type=\"email\" name=\"user\"&gt; &lt;input type=\"password\" name=\"pwd\"&gt;&lt;/form&gt; 提交行为Enter 触发提交当 from 中的 input 文本输入框只有一个时，输入状态下 Enter 键会触发表单提交 12345&lt;form action=\"aip.example.com/s\" method=\"POST\" name=\"login\"&gt; &lt;input type=\"text\" name=\"address\"&gt; &lt;input type=\"radio\" name=\"sex\" value=\"male\"&gt; &lt;input type=\"radio\" name=\"sex\" value=\"female\"&gt;&lt;/form&gt; button 触发提交form 中 type=”submit” 的 button 或 input 元素被点击后触发表单提交。 注意button 元素的 type 属性可选值是 submit button reset 。除了 Internet Explorer，其他浏览器的默认值是 submit。 1234567&lt;form action=\"aip.example.com/s\" method=\"POST\" name=\"login\"&gt; &lt;input type=\"email\" name=\"user\"&gt; &lt;input type=\"password\" name=\"pwd\"&gt; &lt;input type=\"submit\" value=\"提交1\"&gt; &lt;button&gt;提交2&lt;/button&gt; &lt;button type=\"submit\"&gt;提交3&lt;/button&gt;&lt;/form&gt; 调用 form 的 submit 方法1234567&lt;form action=\"aip.example.com/s\" method=\"POST\" name=\"login\"&gt; &lt;input type=\"email\" name=\"user\"&gt; &lt;input type=\"password\" name=\"pwd\"&gt;&lt;/form&gt;&lt;script&gt;document.forms.login.submit()&lt;/script&gt; 校验表单数据1.form 有 checkValidity reportValidity 方法，调用时会校验表单的项的值和其 type pattern 属性相符，返回布尔值2.第三方插件：validate async-validator 等 注意1.这两个方法兼容性不太好2.表单未填写时返回 true 获取表单数据1.使用 FormData 12var data = new FormData(document.forms.login)xhr.send(data) 2.jQuery 序列化 12$('#form_login').serialize() // user=John&amp;pwd=123456$('#form_login').serializeArray() // [{name: \"user\", value: \"John\"}, {name: \"user\", value: \"123456\"}] 阻止默认提交2.指定 form 的 onsubmit 属性值为 return false 123&lt;form onsubmit=\"return false\"&gt; &lt;input type=\"text\" name=\"user\"&gt;&lt;/form&gt; 1.监听 form 的 submit 事件并阻止默认事件 123456789&lt;form name=\"login\"&gt; &lt;input type=\"text\" name=\"user\"&gt;&lt;/form&gt;&lt;script&gt;document.forms.login.addEventListener('submit', function(e) { e.preventDefault() // send form data ...})&lt;/script&gt; 注意使用 onsubmit 属性监听的提交事件无法阻止默认提交 — The End —","link":"/html/2017/03/06/"},{"title":"HTML5 是什么 ?","text":"HTML5 新一代开发Web富客户端应用程序整体解决方案，“新一代的 HTML 版本”只是侠义的概念。H5 草案前身 Web Addplication，提出 by WHATWG @2004，接纳 by W3C @2007，2014 年发布,主要在 HTML，CSS，JAVASCRIPT 上有很大的升级。 标签 更具语义化，开发者阅读和写出更优雅的代码，更好地搜索引擎优化 应用程序标签 移除的一些元素，提倡结构表现分离 👉 html5 新增的标签，废弃的标签 属性 链接关系 rel 结构数据标记 无障碍富互联网应用程序 （ARIA） 自定义属性 data 智能表单 👉 html5 元素新增了一些新的属性 网页多媒体 音频 视频 字幕 👉 html5 新增的多媒体特性 新的 API 新的 DOM 选择器 操作类名 访问历史 API 全屏 API 拖放操作 FileReader 👉 html5 新增的 API CanvasSVG浏览器新特性 网页存储 设备信息访问 网络访问 桌面通知 多线程 👉 html5 新增的浏览器特性 CSS3 选择器 颜色 文本 边框 背景 渐变 伸缩布局 3d 过渡 媒体查询 web 字体 👉 绚丽的 CSS3 — The End —","link":"/html/2017/02/14/"},{"title":"html5 新增的标签，废弃的标签","text":"HTML5 提供了一些新的标签，新标签含有语义化、描述文档解构，更优雅的代码，更好地搜索引擎优化。同时也废除了一些旧的标签。 新增的标签aside标签定义其所处内容之外的内容，aside 的内容应该与附近的内容相关 12345&lt;p&gt;Me and my family visited The Epcot center this summer.&lt;/p&gt;&lt;aside&gt;&lt;h4&gt;Epcot Center&lt;/h4&gt;The Epcot Center is a theme park in Disney World, Florida.&lt;/aside&gt; header定义文档或者文档的一部分区域的页眉，元素应该作为介绍内容或者导航链接栏的容器。 123456&lt;article&gt; &lt;header&gt; &lt;h1&gt;Internet Explorer 9&lt;/h1&gt; &lt;/header&gt; &lt;p&gt;Windows Internet Explorer 9(缩写为 IE9 )是在2011年3月14日21:00发布的&lt;/p&gt;&lt;/article&gt; nav标签定义导航链接的部分。 12345&lt;nav&gt; &lt;a href=\"index.asp\"&gt;Home&lt;/a&gt; &lt;a href=\"html5_meter.asp\"&gt;Previous&lt;/a&gt; &lt;a href=\"html5_noscript.asp\"&gt;Next&lt;/a&gt;&lt;/nav&gt; main标签规定文档的主要内容，内容对于文档来说应当是唯一的。它不应包含在文档中重复出现的内容，比如侧栏、导航栏、版权信息、站点标志或搜索表单 12345678&lt;main&gt; &lt;h1&gt;Web Browsers&lt;/h1&gt; &lt;p&gt;Google Chrome、Firefox 以及 Internet Explorer 是目前最流行的浏览器。&lt;/p&gt; &lt;article&gt; &lt;h1&gt;Mozilla Firefox&lt;/h1&gt; &lt;p&gt;Firefox 是一款来自 Mozilla 的免费开源 web 浏览器，发布于 2004 年。&lt;/p&gt; &lt;/article&gt;&lt;/main&gt; 注意在一个文档中，不能出现一个以上的 &lt;main&gt; 元素。&lt;main&gt; 元素不能是以下元素的后代：&lt;article&gt;、&lt;aside&gt;、&lt;footer&gt;、&lt;header&gt; 或 &lt;nav&gt;。另外，IE 不支持该元素 hgroup标签用于对网页或区段（section）的标题进行组合。 1234&lt;hgroup&gt; &lt;h1&gt;Welcome to my WWF&lt;/h1&gt; &lt;h2&gt;For a living planet&lt;/h2&gt;&lt;/hgroup&gt; 请使用 figcaption 元素为元素组添加标题。 section&lt;section&gt; 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分 1234&lt;section&gt; &lt;h1&gt;PRC&lt;/h1&gt; &lt;p&gt;The People's Republic of China was born in 1949...&lt;/p&gt;&lt;/section&gt; article标签规定独立的自包含内容，如：论坛帖子、报纸文章、博客条目、用户评论。一篇文章应有其自身的意义，应该有可能独立于站点的其余部分对其进行分发。 1234&lt;article&gt; &lt;h1&gt;Internet Explorer 9&lt;/h1&gt; &lt;p&gt;Windows Internet Explorer 9（简称 IE9）于 2011 年 3 月 14 日发布.....&lt;/p&gt;&lt;/article&gt; figure figcaption标签规定独立的流内容（图像、图表、照片、代码等等），figure 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。&lt;figcaption&gt; 标签定义 figure 元素的标题（caption），应该被置于 “figure” 元素的第一个或最后一个子元素的位置。 1234&lt;figure&gt; &lt;figcaption&gt;弹琴的兔子&lt;/figcaption&gt; &lt;img src=\"https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif?imageView2/1/w/80/h/80\" width=\"350\" height=\"234\" /&gt;&lt;/figure&gt; footer定义文档或节的页脚，元素应当含有其包含元素的信息。页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等。您可以在一个文档中使用多个 &lt;footer&gt; 元素 1234&lt;footer&gt; &lt;p&gt;Posted by: W3School&lt;/p&gt; &lt;p&gt;Contact information: &lt;a href=\"mailto:someone@example.com\"&gt;someone@example.com&lt;/a&gt;.&lt;/p&gt;&lt;/footer&gt; mark标签定义带有记号的文本。请在需要突出显示文本时使用 &lt;mark&gt; 标签。 1&lt;p&gt;Do not forget to buy &lt;mark&gt;milk&lt;/mark&gt; today.&lt;/p&gt; outputIE 不支持 输出 a b 的和12345&lt;form oninput=\"x.value=parseInt(a.value)+parseInt(b.value)\"&gt; 0&lt;input type=\"range\" id=\"a\" value=\"50\"&gt;100 +&lt;input type=\"number\" id=\"b\" value=\"50\"&gt; =&lt;output name=\"x\" for=\"a b\"&gt;&lt;/output&gt;&lt;/form&gt; time定义公历的时间（24 小时制）或日期，时间和时区偏移是可选的，该元素能够以机器可读的方式对日期和时间进行编码，这样，举例说，用户代理能够把生日提醒或排定的事件添加到用户日程表中，搜索引擎也能够生成更智能的搜索结果。 1&lt;p&gt;我们在每天早上 &lt;time&gt;9:00&lt;/time&gt; 开始营业。&lt;/p&gt; 支持属性 属性 值 描述 datetime datetime 规定日期 / 时间。否则，由元素的内容给定日期 / 时间。 pubdate pubdate 指示 &lt;time&gt; 元素中的日期 / 时间是文档（或 &lt;article&gt; 元素）的发布日期。 注意目前所有主流浏览器都不支持 &lt;time&gt; 标签。 datalist数据列表 12345&lt;input type=\"text\" list=\"input_list\"&gt;&lt;datalist id=\"input_list\"&gt; &lt;option value=\"Johan\"&gt;&lt;/option&gt; &lt;option value=\"Jason\"&gt;&lt;/option&gt;&lt;/datalist&gt; progress进度条 1&lt;progress value=\"10\" max=\"100\"&gt;&lt;/progress&gt; meter度量衡 仅用于已知最大和最小值的度量。IE 不支持 1&lt;meter min=\"0\" max=\"100\" low=\"40\" high=\"90\" optimum=\"100\" value=\"91\"&gt;&lt;/meter&gt; keygen规定用于表单的密钥对生成器字段。当提交表单时，私钥存储在本地，公钥发送到服务器 12345&lt;form action=\"demo_keygen.asp\" method=\"get\"&gt; Username: &lt;input type=\"text\" name=\"usr_name\" /&gt; Encryption: &lt;keygen name=\"security\" /&gt; &lt;input type=\"submit\" /&gt;&lt;/form&gt; 所有主流浏览器都支持 标签，除了 Internet Explorer 和 Safari summary包含 details 元素的标题，”details” 元素用于描述有关文档或文档片段的详细信息。 1234&lt;details&gt; &lt;summary&gt;HTML 5&lt;/summary&gt; This document teaches you everything you have to learn about HTML 5.&lt;/details&gt; “summary” 元素应该是 “details” 元素的第一个子元素。 details用于描述文档或文档某个部分的细节。 1234&lt;details&gt; &lt;summary&gt;Copyright 2011.&lt;/summary&gt; &lt;p&gt;All pages and graphics on this web site are the property of W3School.&lt;/p&gt;&lt;/details&gt; 目前只有 Chrome 支持 标签。与 标签 配合使用可以为 details 定义标题。标题是可见的，用户点击标题时，会显示出 details。 menu定义菜单列表。当希望列出表单控件时使用该标签。 1234&lt;menu&gt; &lt;li&gt;&lt;input type=\"checkbox\" /&gt;Red&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\" /&gt;blue&lt;/li&gt;&lt;/menu&gt; command示用户能够调用的命令，可以定义命令按钮，比如单选按钮、复选框或按钮。只有当 command 元素位于 menu 元素内时，该元素才是可见的。否则不会显示这个元素，但是可以用它规定键盘快捷键 123&lt;menu&gt;&lt;command onclick=\"alert('Hello World')\"&gt;Click Me!&lt;/command&gt;&lt;/menu&gt; 目前只有 Internet Explorer 支持 标签。 bdi允许您设置一段文本，使其脱离其父元素的文本方向设置。在发布用户评论或其他您无法完全控制的内容时，该标签很有用。 embed定义嵌入的内容，比如插件。 1&lt;embed src=\"helloworld.swf\" width=\"500\" height=\"300\"/&gt; 废除的标签html5 提倡结构表现分离，原来哪些为了实现某种样式而定义的标签被废除了。 &lt;applet&gt; &lt;basefont&gt; &lt;big&gt; &lt;center&gt; &lt;dir&gt; &lt;font&gt; frame frameset &lt;noframe&gt; &lt;s&gt; &lt;strike&gt; &lt;tt&gt; &lt;u&gt; 注意IE8/IE7/IE6 不支持这些新标签，可以使用 htmlshiv.js 做兼容。他的原理是通过 document.createElement 创建标签 12345&lt;head&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js\"&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt; — The End —","link":"/html/2017/02/16/"},{"title":"HTML中的 img 标签","text":"在一开始时，Web 仅有文本，那真的是很无趣。自从有了 img 开始 。。。 属性src图片的源地址。可以是 url 、 base64 编码的图片、指向某个 svg 各种图片的特点： 类型 特点 JPEG（jpg） 支持的颜色多，可压缩，但不支持透明 GIF 支持的颜色少，支持动态图，支持简单的透明（要求颜色单一，形状规整，不然效果很差） PNG 支持颜色多，并支持复杂的透明 SVG 可缩放矢量图，体积小，放大不失真，但似乎色彩不是特别丰富 ICON 文字亦是图片，所以颜色单一，放大不失真，体积以 Byte 计 width 、height定义 img 的尺寸，单位是 px ，可省略。如果只定义其中一个，另一个会按比例缩放以保持图片的原始比例。 altalternate 是备用，当图片加载失败是要显示的文字，建议总是写上，被搜索引擎收录。 ismap将图像规定为服务器端图像映射。ismap 属性是一个布尔属性。当点击一个服务器端图像映射时，点击坐标会以 URL 查询字符串的形式发送到服务器 123&lt;a href=\"#\"&gt; &lt;img src=\"https://octodex.github.com/images/mountietocat.png\" alt=\"github.com\" ismap width=\"128\"&gt;&lt;/a&gt; &lt;a&gt; 的 href 属性可以指向后端接口。 点击下面的图片，注意地址栏变化👇 click 事件的 event 对象中保存了点击的坐标，其中 event.offsetX、event.offsetY 就是被点击元素上的坐标。 注意：只有当 &lt;img&gt; 元素属于带有有效 href 属性的 &lt;a&gt; 元素的后代时，才允许使用 ismap 属性。 usemap将图像定义为客户器端图像映射。定义不同的图片区域点击的行为 12345&lt;img src=\"https://octodex.github.com/images/mountietocat.png\" alt=\"github.com\" usemap =\"#mountietocat\" width=\"128\"&gt;&lt;map name=\"mountietocat\"&gt; &lt;area shape=\"rect\" coords=\"15,10,126,50\" href=\"javascript:alert('click hat')\" alt=\"hat\" /&gt; &lt;area shape=\"circle\" coords=\"63,60,15\" href=\"javascript:alert('click face')\" alt=\"face\" /&gt;&lt;/map&gt; 点击下面图片的帽子和脸部中间试试👇 &lt;img&gt; 中的 usemap 属性可引用 &lt;map&gt; 中的 id 或 name 属性（取决于浏览器），所以我们应同时向 &lt;map&gt; 添加 id 和 name 属性。area 元素永远嵌套在 map 元素内部。area 元素可定义图像映射中的区域。 注意在 HTML5 中, 如果 id 属性在 &lt;map&gt; 标签中指定, 则你必须同样指定 name 属性。 crossorigin跨域获取图片失败时，设置图像的跨域属性。有如下两个值： 值 描述 anonymous 不会通过 cookies，客户端 SSL 证书或 HTTP 认证交换用户凭据。 use-credentials 对此元素的CORS请求将设置凭证标志; 这意味着请求将提供凭据。 前提是跨域服务器必须通过 Access-Controll-Allow-Origin 头信息允许当前域名可以获取资源 — The End —","link":"/html/2017/03/16/"},{"title":"HTML中的 script 标签","text":"浏览器在解析 html 文档时，当遇到 script 标签，如果是内嵌脚本，会立即执行脚本里的语句，如果是外链脚本，会立即向服务器请求该脚本。执行脚本时，默认是按引入的顺序，从上往下一次执行。所以在 body 标签内的最底部引入 js 脚本，仍然是引入外部 js 的最佳实践。 以下列举 script 标签的几个常用属性和 2 个新增属性 src该属性可选，当设置了该属性后，script 标签内书写的 js 语句将被忽略 type该属性可选，表示代码使用的脚本语言的类型（也称 MIME 类型），HTML5 中默认是 text/javascript。当值为 module 时，支持 ES6 模块规范的浏览器会异步加载脚本。 language该属性已被废弃 charset该属性可选，表示 src 属性引入内容的字符集 defer表示延迟脚本。该属性可选，只对外部脚本文件有效浏览器解析到带 defer 属性的 script 标签时，会立即下载对应的脚本文件，但不会立即执行脚本文件的语句。待到 html 文档解析完成后，DOMContentLoaded 事件执行之前，再按 脚本的引入顺，依次序执行。也就是说使用该属性后，脚本放在 head 标签内，不会阻塞 html 的解析。 async表示异步脚本，该属性可选，只对外部脚本文件有效。浏览器解析到带 async 属性的 script 标签时，会立即下载对应的脚本文件，并执行！也就是说，脚本可能因为体积小的提前加载而提前执行。所以脚本之间如果没有依赖关系，可以使用该属性。使用该属性后，脚本放在 head 标签内，不会阻塞 html 的解析。但不建议在脚本内修改 DOM。 — The End —","link":"/html/2017/03/11/"},{"title":"HTML中的 meta 标签","text":"元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。 标签位于文档的头部，不包含任何内容。 标签的属性定义了与文档相关联的名称/值对。 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 声明文档使用的字符编码 --&gt;&lt;meta charset=\"utf-8\"&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;!-- 为移动设备添加 viewport --&gt;&lt;meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no\"&gt; &lt;!-- 设置页面不缓存 --&gt;&lt;meta http-equiv=\"pragma\" content=\"no-cache\"&gt; &lt;meta http-equiv=\"cache-control\" content=\"no-cache\"&gt;&lt;meta http-equiv=\"expires\" content=\"0\"&gt;&lt;!-- 设置页面 5 秒后跳转到百度 --&gt;&lt;meta http-equiv=\"refresh\" content=\"5;url=https://www.baidu.com\" /&gt;&lt;!-- 优先使用 IE 最新版本和 Chrome --&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"/&gt; &lt;!-- 页面描述 --&gt;&lt;meta name=\"description\" content=\"网页描述\"/&gt;&lt;!-- 页面关键词 --&gt;&lt;meta name=\"keywords\" content=\"web, html\"/&gt;&lt;!-- 网页作者 --&gt;&lt;meta name=\"author\" content=\"name, email@gmail.com\"/&gt;&lt;!-- 搜索引擎抓取 --&gt;&lt;meta name=\"robots\" content=\"index,follow\"/&gt;&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;&lt;meta name=\"renderer\" content=\"webkit\"&gt;&lt;!-- 设置苹果工具栏颜色 --&gt;&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"/&gt;&lt;!-- 侦听电话号码为拨号链接 --&gt;&lt;meta name=\"format-detection\" content=\"telephone=yes\"/&gt; — The End —","link":"/html/2017/03/04/"},{"title":"linux 基础命令","text":"在阿里云买了一个主机，学习 linux 啦~~ 记录学习 linux 过程钟用到的一些指令 注销 logout 登出，只有在运行级别 3 及以下有效 exit 切换用户后，退出返回原来的用户 关机 shutdown 默认 1 分组后关机 -h now 立即关机 -h 30 30min 后关机 halt reboot 重启 sync 把内存数据写入磁盘，防止数据丢失 运行级别 init 0 关机 1 单用户（找回丢失密码） 2 多用户，无网络 3 多用户，有网络 4 保留 5 图形界面 6 重启 帮助 man ls 查看 ls 命令 help cp 查看 cp 命令 用户 useradd 添加用户 John 添加用户 John -d /home/joh John 指定用户目录在 /home/joh -g dev John 指定用户在 dev 组 userdel 删除用户 John 删除用户 John -r John 同时删除 John 的用户目录 usermod 修改用户 -g test John 修改 John 所在组为 test -d /home/T Tom 修改用户 Tom 登录后的初始目录为 /hoem/T passwd 修改密码 John 修改 John 的密码 who am i 显示当前用户 id 查询用户 John 返回用户 ID 、组 ID 、组名称 su 切换用户 root 切换到 root 用户 组 groupadd 添加组 dev 添加 dev 组 groupdel 删除组 dev 删除 dev 组 路径 cd ~ 回到用户家目录 pwd 显示当前所在目录 echo $PATH 输出当前环境变量路径 新键、删除、移动、复制 mkdir -p 一次创建多级目录 rmdir 只能删除空目录 touch 创建空文件，可一次创建多个 rm file 删除文件 -f file 强制文件，不要求确认 -r somedir/ 删除目录 somedir 及子目录、文件，/ 可写可不写 cp -r source dest 拷贝目录 source 到 dest（若 dest 目录不存在，则复制 source 并重命名为 dest） \\cp -r source dest 强制覆盖目标同名文件 mv source dest 移动文件或目录（若 dest 不存在，则 source 并重命名为 dest） 查看文件 cat 只读的方式打开文件 a.txt -n a.txt 显示行号 a.txt | more 一页一页显示，Space 下一页 more 基于 vi 编辑器，按页显示文本内容，显示百分比 Space 下一页，Enter 下一行，Ctrl + f 滚动下一屏，Ctrl + b 返回上一屏 q 离开 = 输出当前行行号，:f 输出文件名和当前行行号 less 功能强大，查看大文件效率高 Space、f 下一页，w 上一页，也可用 PageDown PageUp ，Enter 下一行 /keywrod 或者 ?keyword 搜索关键字，n 匹配下一处，Shift + n 匹配上一处 q 离开 head 显示文件开头部分，默认显示前 10 行 -n 15 显示文件前 15 行 tail 显示文件尾部部分，默认显最后 10 行 -n 15 显示文件最后 15 行 -f 实时追踪文件更行 输出重定向、追加 ls > dir.txt ls 输出的内容覆盖写入到 dir.txt (dir.txt 不存在会自动创建) ls >> dir.txt ls 输出的内容追加到 dir.txt 软链接 ln ln -s /root root_link 在当前目录下建立 /root 的软链接，源是绝对路径 历史指令 history 显示历史执行的指令 10 显示最近 10 条 !100 执行第 100 条指令 时间日期 cal 显示当月日历 2018 显示 2018 年的日历 date 年月日、星期、时间 +%Y 显示 年，四位 +%Y-%m-%d 显示 年-月-日 '+%Y-%m-%d %H:%M:%S' 显示 年-月-日 时:分:秒 -s 2017-1-1 设置系统日期为 2107-01-01 -s 12:12:12 设置系统时间 12:12:12 压缩、解压 gzip 生成 .gz 文件，压缩后不保留源文件 file1 file2 ... 可压缩多个文件，不支持目录 gunzip 解压后不保留 .gz 压缩包 zip 生成 .zip 文件 home.zip -r /home 同下 -r home.zip /home/ 缩目录 /home/ 为 home.zip ，可压缩多个文件(夹)，最后的 / 可不写 最后的参数必须时文件(夹)，不指定 home.zip 会采用第一个文件(夹)名 unzip -d /temp home.zip 解压 home.zip 到 /temp 目录，如果目录不存在，会自动创建 home.zip -d /temp 同上 tar 生成 .tar.gz 文件 -c 压缩 -v 显示详细信息 -f 指定压缩后文件名 -z 打包同时压缩 -x 解压 tar -zcvf dist.tar.gz a.txt b.txt ... 压缩指定文件(夹) 为 dist.tar.gz tar -xf dist.tar.gz -C /temp 解压dist.tar.gz 到 /temp 目录里，-C /temp 参数可选 文件(夹)权限变更所有者，所在组 chown Tom file 修改文件(夹) file 所有者为 Tom -R Tom somedir/ 修改文件 somedir 及其子目录、文件所有者为 Tom，/ 可不写 chgrp test file 修改文件(夹) file 所在组为 test -R test/ somedir 修改文件夹 somedir 及其子目录、文件所在组为 test，/ 可不写 chmod test:Tom file 修改文件(夹) file 所在组为 test，所有者为 Tom 操作权限符号表示 r 用户有读的权限，对应数字 4 w 用户有写的权限，对应数字 2 x 用户有执行的权限，对应数字 1 - 用户无对应的权限 u 所有者 g 所在组 o 其他人 a 所有人 - 去掉某些权限 + 增加某些权限 = 重新指定权限 修改指令 chmod u+x,g-w,o=r file 对文件所有者增加执行权限，所在组成员去掉写权限，其他组成员权限为只读。 751 file 751 等同 u=rwx,g=r-x,o=x -R a+r somdedir/ 目录 somdedir 及其子目录、文件为所有人增加读权限，/ 可不写 磁盘 df 系统整体磁盘使用情况 -h 带计量单位 du [dir] 目录磁盘使用情况 -h 带计量单位 -s 指定目录（不显示子目录） -a 列出文件 -c 显示汇总值 --max-depth=n 子目录深度 进程查看进程 ps 查看进程 -a 显示当前终端所有进程 -u 以用户的格式显示 -x 显示后台进程 -e 显示所有进程 -f 显示父进程 pstree 树状显示 -u 显示所属用户 -p 显示 PID 终止进程 kill [pid] 终止进程 -9 强制终止 killall [pname] 进程名支持通配符 查看服务 chkconfig [srvname] --list 服务在各个级别下的启动情况，可指定具体的服务名 srv on|off 设置 srv 的启动|关闭 --level 6 srv off 设置 srv 在运行级别 6 下关闭 动态监控进程 top -d n 设定信息刷新频率，单位秒 网络查看网络情况 netstat -an 按一定顺序列出 -p 显示哪个进程在调用 软件包管理Redhat Package Manager rpm -q firefox 查询 firefox 是否安装 -qa 查询已安装的 rmp 软件包 -qi firefox 查询 firefox 软件包信息 -ql firefox 查询 firefox 软件包中的文件 -qf /etc/passwd 查询 passwd 文件所属软件包 -e firefox 卸载 firefox -e --nodeps firefox 卸载 firefox 忽略依赖关系 -i firefox 安装 -v 显示提示 -h 显示进度 — The End —","link":"/linux/2018/04/07/"},{"title":"linux 目录一览","text":"linux 目录一览 / 根 ├─ bin │ ├─ │ └─ │ ├─ boot │ ├─ │ └─ │ ├─ dev │ ├─ sda sda1 sdb ... 磁盘及分区 │ ├─ cpu │ ├─ etc │ ├─ passwd 用户信息配置 │ ├─ group 组信息配置 │ ├─ shadow 密码、登录信息 │ ├─ crontab 任务调度 │ ├─ fstab 分区挂载配置 │ ├─ init.d -> rc.d/init.d 服务 │ │ │ ├─ home │ ├─ John 用户目录 │ └─ Tom 用户目录 │ ├─ lib │ ├─ │ └─ │ ├─ lib64 │ ├─ │ └─ │ ├─ media │ ├─ │ └─ │ │ ├─ mnt │ ├─ │ └─ │ ├─ opt │ ├─ │ └─ │ ├─ proc │ ├─ │ └─ │ ├─ root │ ├─ │ └─ │ ├─ run │ ├─ │ └─ │ ├─ sbin │ ├─ │ └─ │ ├─ srv │ ├─ │ └─ │ ├─ sys │ ├─ │ └─ │ ├─ tmp │ ├─ │ └─ │ ├─ usr │ ├─ │ └─ │ ├─ var │ ├─ │ └─","link":"/linux/2018/04/28/"},{"title":"linux 运行级别","text":"CentOS 7 的运行级别的配置不再是使用 /etc/inittab 文件管理了，而是使用 systemd ，运行级别文件指定在 /lib/systemd/system 目录下：runlevel*.target 查看当前级别1systemctl get-default 设置运行级别init切换图形级别和命令行级别没有变化 1234# 切换到命令行级别init 3# 切换到图形级别init 5 # 或 startx systemctl set-default1234# 切换到命令行运行级别systemctl set-default multi-user.target# 切换到图形运行级别systemctl set-default graphical.target runlevel3.target 和 runlevel5.target 分别是指向 multi-user.target 和 graphical.target 的符号链接 systemctl isolate1234# 切换到命令行运行级别systemctl isolate runlevel3.target# 切换到图形运行级别systemctl isolate runlevel5.target 默认运行级别12# 设置系统启动时运行级别为图形界面ln -sf /lib/systemd/system/graphical.target /etc/systemd/system/default.target — The End —","link":"/linux/2018/04/21/"},{"title":"制作 xlsx.js 可导入的 excel 模板","text":"批量录入固定格式的数据，最简单的方式就是使用 excel 导入了。使用 xlsx.js 可以很轻松的实现数据批量导入。 我们希望数据导入模板有如下特点： 限制输入格式 限制编辑区域 这里要使用到 excel 的 “保护工作簿” “保护工作表” 的功能。这两个功能支持设置密码。 下面以导入物资信息为例，简单记录操作步骤： 1、先编辑 excel 如下 操作：视图 》 窗口 》 冻结窗格 》 冻结首行操作：视图 》显示 》 去掉网格线 2、限制物品价格、物品数量的格式 选择对应列，设置对应的验证条件 操作：数据 》 数据工具 》 数据验证 3、格式化 选中对应列，设置物品价格、物品数量的格式 操作：开始 》 单元格 》 格式 》 设置单元格格式 》 数字 4、保护工作簿 不允许用户增加、删除 sheet 操作：审阅 》 保护 》 保护工作簿 5、限制编辑区域 锁定下图红色线框之外的所有单元格（注意线框以下部分也不锁定），锁定区域为用户不可编辑区域。 操作：开始 》 单元格 》 格式 》 设置单元格格式 》 保护 》 锁定 操作：提示：可以先锁定全部，再解除锁定某些指定的列 完成上述操作后，开启保护工作表功能后就可以了（需要输入密码） 操作：审阅 》 保护 》 保护工作表","link":"/office/2017/05/20/"},{"title":"Web 端测试点一些规则","text":"测试要遵循一定的规则才不会遗漏。 输入框 1、字符型输入框： （1）字符型输入框：英文全角、英文半角、数字、空或者空格、特殊字符“~！@#￥%……&amp;*？[]{}”特别要注意单引号和&amp;符号。禁止直接输入特殊字符时，使用“粘贴、拷贝”功能尝试输入。 （2）长度检查：最小长度、最大长度、最小长度-1、最大长度+1、输入超工字符比如把整个文章拷贝过去。 （3）空格检查：输入的字符间有空格、字符前有空格、字符后有空格、字符前后有空格 （4）多行文本框输入：允许回车换行、保存后再显示能够保存输入的格式、仅输入回车换行，检查能否正确保存（若能，检查保存结果，若不能，查看是否有正常提示）、 （5）安全性检查：输入特殊字符串（null,NULL, ,javascript,,,,,）、输入脚本函数(alert(“abc”))、doucment.write(“abc”)、hello） 2、数值型输入框： （1）边界值：最大值、最小值、最大值+1、最小值-1 （2）位数：最小位数、最大位数、最小位数-1最大位数+1、输入超长值、输入整数 （3）异常值、特殊字符：输入空白（NULL）、空格或”~!@#$%^&amp;*()_+{}|[]\\:”&lt;&gt;?;’,./?;:’-=等可能导致系统错误的字符、禁止直接输入特殊字符时，尝试使用粘贴拷贝查看是否能正常提交、word中的特殊功能，通过剪贴板拷贝到输入框，分页符，分节符类似公式的上下标等、数值的特殊符号如∑，㏒，㏑，∏，+，-等、 输入负整数、负小数、分数、输入字母或汉字、小数（小数前0点舍去的情况，多个小数点的情况）、首位为0的数字如01、02、科学计数法是否支持1.0E2、全角数字与半角数字、数字与字母混合、16进制，8进制数值、货币型输入（允许小数点后面几位）、 （4）安全性检查：不能直接输入就copy 3、日期型输入框： （1）合法性检查：(输入0日、1日、32日)、月输入[1、3、5、7、8、10、12]、日输入[31]、月输入[4、6、9、11]、日输入[30][31]、输入非闰年，月输入[2]，日期输入[28、29]、输入闰年，月输入[2]、日期输入[29、30]、月输入[0、1、12、13] (2)异常值、特殊字符：输入空白或NULL、输入~！@#￥%……&amp;*（）{}[]等可能导致系统错误的字符 （3）安全性检查：不能直接输入，就copy，是否数据检验出错？ 4、信息重复:在一些需要命名,且名字应该唯一的信息输入重复的名字或ID,看系统有没有处理,会否报错,重名包括是否区分大小写,以及在输入内容的前后输入空格,系统是否作出正确处理. 2 二、搜索功能 若查询条件为输入框，则参考输入框对应类型的测试方法 1、功能实现： （1）如果支持模糊查询，搜索名称中任意一个字符是否能搜索到 （2）比较长的名称是否能查到 （3）输入系统中不存在的与之匹配的条件 （4）用户进行查询操作时，一般情况是不进行查询条件的清空，除非需求特殊说明。 2、组合测试： （1）不同查询条件之间来回选择，是否出现页面错误（单选框和多选框最容易出错） （2）测试多个查询条件时，要注意查询条件的组合测试，可能不同组合的测试会报错。 3 三、添加、修改功能 1、特殊键：（1）是否支持Tab键 （2）是否支持回车键 2、提示信息：（1）不符合要求的地方是否有错误提示 3、唯一性：（1）字段唯一的，是否可以重复添加，添加后是否能修改为已存在的字段（字段包括区分大小写以及在输入的内容前后输入空格，保存后，数据是否真的插入到数据库中，注意保存后数据的正确性） 4、数据 正确性： （1）对编辑页的每个编辑项进行修改，点击保存，是否可以保存成功，检查想关联的数据是否得到更新。 （2）进行必填项检查（即是否给出提示以及提示后是否依然把数据存到数据库中；是否提示后出现页码错乱等） （3）是否能够连续添加（针对特殊情况） （4）在编辑的时候，注意编辑项的长度限制，有时在添加的时候有，在编辑的时候却没有（注意要添加和修改规则是否一致） （5）对于有图片上传功能的编辑框，若不上传图片，查看编辑页面时是否显示有默认的图片，若上传图片，查看是否显示为上传图片 （6）修改后增加数据后，特别要注意查询页面的数据是否及时更新，特别是在首页时要注意数据的更新。 （7）提交数据时，连续多次点击，查看系统会不会连续增加几条相同的数据或报错。 （8）若结果列表中没有记录或者没选择某条记录，点击修改按钮，系统会抛异常。 4 四、删除功能 1、特殊键：（1）是否支持Tab键 （2）是否支持回车键 2、提示信息：（1）不选择任何信息，直接点击删除按钮，是否有提示（2）删除某条信息时，应该有确认提示 3、数据 实现：（1）是否能连续删除多个产品（2）当只有一条数据时，是否可以删除成功 （3）删除一条数据后，是否可以添加相同的数据（4）如系统支持批量删除，注意删除的信息是否正确 （5）如有全选，注意是否把所有的数据删除（6）删除数据时，要注意相应查询页面的数据是否及时更新 （7）如删除的数据与其他业务数据关联，要注意其关联性（如删除部门信息时，部门下游员工，则应该给出提示）（8）如果结果列表中没有记录或没有选择任何一条记录，点击删除按钮系统会报错。 如：某一功能模块具有最基本的增删改查功能，则需要进行以下测试 单项功能测试（增加、修改、查询、删除） 增加——&gt;增加——&gt;增加 （连续增加测试） 增加——&gt;删除 增加——&gt;删除——&gt;增加 （新增加的内容与删除内容一致） 增加——&gt;修改——&gt;删除 修改——&gt;修改——&gt;修改 （连续修改测试） 修改——&gt;增加（新增加的内容与修改前内容一致） 修改——&gt;删除 修改——&gt;删除——&gt;增加 （新增加的内容与删除内容一致） 删除——&gt;删除——&gt;删除 （连续删除测试） 5 五、注册、登陆模块 1、注册功能： （1）注册时，设置密码为特殊版本号，检查登录时是否会报错 （2）注册成功后，页面应该以登陆状态跳转到首页或指定页面 （3）在注册信息中删除已输入的信息，检查是否可以注册成功。 2、登陆 功能： （1）输入正确的用户名和正确的密码 （2）输入正确的用户名和错误的密码 （3）输入错误的用户名和正确的密码 （4）输入错误的用户名和错误的密码 （5）不输入用户名和密码（均为空格） （6）只输入用户名，密码为空 （7）用户名为空，只输入密码 （8）输入正确的用户名和密码，但是不区分大小写 （9）用户名和密码包括特殊字符 （10）用户名和密码输入超长值 （11）已删除的用户名和密码 （12）登录时，当页面刷新或重新输入数据时，验证码是否更新 6 六、上传图片测试 1、功能 实现： （1）文件类型正确、大小合适 （2）文件类型正确，大小不合适 （3）文件类型错误，大小合适 （4）文件类型和大小都合适，上传一个正在使用中的图片 （5）文件类型大小都合适，手动输入存在的图片地址来上传 （6）文件类型和大小都合适，输入不存在的图片地址来上传 （7）文件类型和大小都合适，输入图片名称来上传 （8）不选择文件直接点击上传，查看是否给出提示 （9）连续多次选择不同的文件，查看是否上传最后一次选择的文件 6 七、查询结果列表 1、功能 实现： （1）列表、列宽是否合理 （2）列表数据太宽有没有提供横向滚动 （3）列表的列名有没有与内容对应 （4）列表的每列的列名是否描述的清晰 （5）列表是否把不必要的列都显示出来 （6）点击某列进行排序，是否会报错（点击查看每一页的排序是否正确） （7）双击或单击某列信息，是否会报错 8 八、返回键检查 1、一条已经成功提交的记录，返回后再提交，是否做了处理 2、检查多次使用返回键的情况，在有返回键的地方，返回到原来的页面多次，查看是否会出错 11 九、回车键检查 1、在输入结果后，直接按回车键，看系统如何处理，是否会报错 10 十、刷新键检查 1、在Web系统中，使用刷新键，看系统如何处理，是否会报错 11 十一、直接URL链接检查 1、在Web系统中，在地址栏直接输入各个功能页面的URL地址，看系统如何处理，是否能够直接链接查看（匿名查看），是否有权限控制，是否直接执行，并返回相应结果页； 12 十二、界面和易用性测试 1、风格、样式、颜色是否协调 2、界面布局是否整齐、协调（保证全部显示出来的，尽量不要使用滚动条 3、界面操作、标题描述是否恰当（描述有歧义、注意是否有错别字） 4、操作是否符合人们的常规习惯（有没有把相似的功能的控件放在一起，方便操作） 5、提示界面是否符合规范（不应该显示英文的cancel、ok，应该显示中文的确定等） 6、界面中各个控件是否对齐 7、日期控件是否可编辑 8、日期控件的长度是否合理，以修改时可以把时间全部显示出来为准 9、查询结果列表列宽是否合理、标签描述是否合理 10、查询结果列表太宽没有横向滚动提示 11、对于信息比较长的文本，文本框有没有提供自动竖直滚动条 12、数据录入控件是否方便 13、有没有支持Tab键，键的顺序要有条理，不乱跳 14、有没有提供相关的热键 15、控件的提示语描述是否正确 16、模块调用是否统一，相同的模块是否调用同一个界面 17、用滚动条移动页面时，页面的控件是否显示正常 18、日期的正确格式应该是XXXX-XX-XX或XXXX-XX-XX XX:XX:XX 19、页面是否有多余按钮或标签 20、窗口标题或图标是否与菜单栏的统一 21、窗口的最大化、最小化是否能正确切换 22、对于正常的功能，用户可以不必阅读用户手册就能使用 23、执行风险操作时，有确认、删除等提示吗 24、操作顺序是否合理 25、正确性检查：检查页面上的form, button, table, header, footer,提示信息，还有其他文字拼写，句子的语法等是否正确。 26、系统应该在用户执行错误的操作之前提出警告，提示信息. 27、页面分辨率检查，在各种分辨率浏览系统检查系统界面友好性。 28、合理性检查：做delete, update, add, cancel, back等操作后，查看信息回到的页面是否合理。 29、检查本地化是否通过：英文版不应该有中文信息，英文翻译准确，专业。 13 十三、兼容性测试 兼容性测试不只是指界面在不同操作系统或浏览器下的兼容，有些功能方面的测试，也要考虑到兼容性， 包括操作系统兼容和应用软件兼容，可能还包括硬件兼容 比如涉及到ajax、jquery、javascript等技术的，都要考虑到不同浏览器下的兼容性问题。 14 十四、链接测试 主要是保证链接的可用性和正确性，它也是网站测试中比较重要的一个方面。 可以使用特定的工具如XENU来进行链接测试。 1导航测试 导航描述了用户在一个页面内操作的方式，在不同的用户接口控制之间，例如按钮、对话框、列表和窗口等；或在不同的连接页面之间。通过考虑下列问题，可以决定一个Web应用系统是否易于导航：导航是否直观？Web系统的主要部分是否可通过主页存取？Web系统是否需要站点地图、搜索引擎或其他的导航帮助？ 在一个页面上放太多的信息往往起到与预期相反的效果。Web应用系统的用户趋向于目的驱动，很快地扫描一个Web应用系统，看是否有满足自己需要的信息，如果没有，就会很快地离开。很少有用户愿意花时间去熟悉Web应用系统的结构，因此，Web应用系统导航帮助要尽可能地准确。 导航的另一个重要方面是Web应用系统的页面结构、导航、菜单、连接的风格是否一致。确保用户凭直觉就知道Web应用系统里面是否还有内容，内容在什么地方。 Web应用系统的层次一旦决定，就要着手测试用户导航功能，让最终用户参与这种测试，效果将更加明显。 2图形测试 在Web应用系统中，适当的图片和动画既能起到广告宣传的作用，又能起到美化页面的功能。一个Web应用系统的图形可以包括图片、动画、边框、颜色、字体、背景、按钮等。图形测试的内容有： （1）要确保图形有明确的用途，图片或动画不要胡乱地堆在一起，以免浪费传输时间。Web应用系统的图片尺寸要尽量地小，并且要能清楚地说明某件事情，一般都链接到某个具体的页面。 （2）验证所有页面字体的风格是否一致。 （3）背景颜色应该与字体颜色和前景颜色相搭配。 （4）图片的大小和质量也是一个很重要的因素，一般采用JPG或GIF压缩，最好能使图片的大小减小到30k以下 （5）最后，需要验证的是文字回绕是否正确。如果说明文字指向右边的图片，应该确保该图片出现在右边。不要因为使用图片而使窗口和段落排列古怪或者出现孤行。 通常来说，使用少许或尽量不使用背景是个不错的选择。如果您想用背景，那么最好使用单色的，和导航条一起放在页面的左边。另外，图案和图片可能会转移用户的注意力。 15 十五、业务流程测试（主要功能测试） 业务流程，一般会涉及到多个模块的数据，所以在对业务流程测试时，首先要保证单个模块功能的正确性，其次就要对各个模块间传递的数据进行测试，这往往是容易出现问题的地方，测试时一定要设计不同的数据进行测试。 16 十六、安全性测试 （1）SQL注入（比如登陆页面） （2）XSS跨网站脚本攻击：程序或数据库没有对一些特殊字符进行过滤或处理，导致用户所输入的一些破坏性的脚本语句能够直接写进数据库中，浏览器会直接执行这些脚本语句，破坏网站的正常显示，或网站用户的信息被盗,构造脚本语句时，要保证脚本的完整性。 document.write(“abc”) alter(“abc”) （3）URL地址后面随便输入一些符号，并尽量是动态参数靠后 （4）验证码更新问题 （5）现在的Web应用系统基本采用先注册，后登陆的方式。因此，必须测试有效和无效的用户名和密码，要注意到是否大小写敏感，可以试多少次的限制，是否可以不登陆而直接浏览某个页面等。 （6）Web应用系统是否有超时的限制，也就是说，用户登陆后在一定时间内（例如15分钟）没有点击任何页面，是否需要重新登陆才能正常使用。 （7）为了保证Web应用系统的安全性，日志文件是至关重要的。需要测试相关信息是否写进了日志文件、是否可追踪。 （8）当使用了安全套接字时，还要测试加密是否正确，检查信息的完整性。 （9）服务器端的脚本常常构成安全漏洞，这些漏洞又常常被黑客利用。所以，还要测试没有经过授权，就不能在服务器端放置和编辑脚本的问题。 17 十七、性能测试 1连接速度测试 用户连接到Web应用系统的速度根据上网方式的变化而变化，他们或许是电话拨号，或是宽带上网。当下载一个程序时，用户可以等较长的时间，但如果仅仅访问一个页面就不会这样。如果Web系统响应时间太长（例如超过5秒钟），用户就会因没有耐心等待而离开。 另外，有些页面有超时的限制，如果响应速度太慢，用户可能还没来得及浏览内容，就需要重新登陆了。而且，连接速度太慢，还可能引起数据丢失，使用户得不到真实的页面。 2负载测试 负载测试是为了测量Web系统在某一负载级别上的性能，以保证Web系统在需求范围内能正常工作。负载级别可以是某个时刻同时访问Web系统的用户数量，也可以是在线数据处理的数量。例如：Web应用系统能允许多少个用户同时在线？如果超过了这个数量，会出现什么现象？Web应用系统能否处理大量用户对同一个页面的请求？ 3压力测试 负载测试应该安排在Web系统发布以后，在实际的网络环境中进行测试。因为一个企业内部员工，特别是项目组人员总是有限的，而一个Web系统能同时处理的请求数量将远远超出这个限度，所以，只有放在Internet上，接受负载测试，其结果才是正确可信的。 进行压力测试是指实际破坏一个Web应用系统，测试系统的反映。压力测试是测试系统的限制和故障恢复能力，也就是测试Web应用系统会不会崩溃，在什么情况下会崩溃。黑客常常提供错误的数据负载，直到Web应用系统崩溃，接着当系统重新启动时获得存取权。 压力测试的区域包括表单、登陆和其他信息传输页面等。 备注： 1、负载/压力测试应该关注什么 测试需要验证系统能否在同一时间响应大量的用户，在用户传送大量数据的时候能否响应，系统能否长时间运行。可访问性对用户来说是极其重要的。如果用户得到“系统忙”的信息，他们可能放弃，并转向竞争对手。系统检测不仅要使用户能够正常访问站点，在很多情况下，可能会有黑客试图通过发送大量数据包来攻击服务器。出于安全的原因，测试人员应该知道当系统过载时，需要采取哪些措施，而不是简单地提升系统性能。 1）瞬间访问高峰 如果您的站点用于公布彩票的抽奖结果，最好使系统在中奖号码公布后的一段时间内能够响应上百万的请求。负载测试工具能够模拟X个用户同时访问测试站点。 2）每个用户传送大量数据 网上书店的多数用户可能只订购1-5书，但是大学书店可能会订购5000本有关心理学介绍的课本?或者一个祖母为她的50个儿孙购买圣诞礼物(当然每个孩子都有自己的邮件地址)系统能处理单个用户的大量数据吗? 3）长时间的使用 如果站点用于处理鲜花订单，那么至少希望它在母亲节前的一周内能持续运行。如果站点提供基于web的email服务，那么点最好能持续运行几个月，甚至几年。可能需要使用自动测试工具来完成这种类型的测试，因为很难通过手工完成这些测试。你可以想象组织100个人同时点击某个站点。但是同时组织100000个人呢。通常，测试工具在第二次使用的时候，它创造的效益，就足以支付成本。而且，测试工具安装完成之后，再次使用的时候，只要点击几下。 采取措施：采用性能测试工具WAS、ACT，LR等协助进行测试 18 十八、测试中应该注意的其他情况 1、在测试时，与网络有关的步骤或者模块必须考虑到断网的情况 2、每个页面都有相应的Title，不能为空，或者显示“无标题页” 3、在测试的时候要考虑到页面出现滚动条时，滚动条上下滚动时，页面是否正常 4、URL不区分大小写，大小写不敏感 5、、对于电子商务网站，当用户并发购买数量大于库存的数量时，系统如何处理 6、测试数据避免单纯输入“123”、“abc“之类的，让测试数据尽量接近实际 7、进行测试时，尽量不要用超级管理员进行测试，用新建的用户进行测试。测试人员尽量不要使用同一个用户进行测试 8、提示信息：提示信息是否完整、正确、详细 9、帮助信息：是否提供帮助信息，帮助信息的表现形式（页面文字、提示信息、帮助文件），帮助信息是否正确、详细 10、可扩展性：是否由升级的余地，是否保留了接口 11、稳定性：运行所需的软硬件配置，占用资源情况，出现问题时的容错性，对数据的保护 12、运行速度：运行的快慢，带宽占用情况 — The End —","link":"/test/2017/03/13/"},{"title":"正向代理与反向代理的解释","text":"如果你喝醉了酒，不想酒驾被抓，你会想到找个代驾的司机。如果你不小心摊上官司了，而你不懂法律，你会想到找一个代理律师。这就是代理的意义。而网络代理分正向代理和反向代理。 正向代理当你输入 www.google.com ，发现没有响应，于是你找了个 Shadowsocks ，成功打开了 google 。Shadowsocks 所做的事，就是帮你去访问 google 把得到的资源返回给你，它实现的功能就是代理。但是 google 认为请求来自 Shadowsocks ，而不知道正在的请求者是你！这就是正向代理，即对服务器隐藏了真正的客户端。 反向代理作为全球搜索引擎的老大，google 的并发请求难以想象！google 有数百万（可能是千万）服务器响应客户端的请求！当你输入关键字搜索时，到底是其中哪一台给你的响应？你不知道，也决定不了，你只知道 google 响应了你的请求。中间有一层服务把你的请求转发给合适的那一台服务器，它所做的事就是反向代理，即对客户端隐藏了真正的服务器。 — The End —","link":"/proxy/2017/04/15/"},{"title":"这些 js 的写法很有意思","text":"网上涉略各种论坛，博客，发现一些很有意思的 js 写法，在此做个收集，但不整理。可以给自己灵感，也希望对你有用 作者：殷荣桧链接：https://juejin.im/post/5becf928f265da61380ec986来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。1234const address = 'One Infinite Loop, Cupertino 95014';const cityZipCodeRegex = /^[^,\\\\]+[,\\\\\\s]+(.+?)\\s*(\\d{5})?$/;const [, city, zipCode] = address.match(cityZipCodeRegex) || [];saveCityZipCode(city, zipCode); 作者：Think.链接：https://juejin.im/post/5bdfef86e51d453bf8051bf8来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。12345678910111213141516const actions = ()=&gt;{ const functionA = ()=&gt;{/*do sth*/} const functionB = ()=&gt;{/*do sth*/} const functionC = ()=&gt;{/*send log*/} return new Map([ [/^guest_[1-4]$/,functionA], [/^guest_5$/,functionB], [/^guest_.*$/,functionC], //... ])}const onButtonClick = (identity,status)=&gt;{ let action = [...actions()].filter(([key,value])=&gt;(key.test(`${identity}_${status}`))) action.forEach(([key,value])=&gt;value.call(this))} — The End —","link":"/js/2017/09/23/"},{"title":"html5 新增的浏览器特性","text":"web 浏览器的升级，是 HTML5 的一部分，使得前端可以开发更加强大复杂的 web 应用。 网页存储Application Cache 该特性已经从 Web 标准中删除，建议开发人员改用 Service workers 代替 localStorage sessionStorage浏览器增加了 Storage 对象，用于本地数据存储的功能，不同浏览器的存储空间在 2.5M - 8M 不等。IE8+ 支持，兼容性良好 localStorage sessionStorage 是 Storage 的实例，它们有相同的接口。不同的是 localStorage 能持久的存储数据，sessionStorage 存储的数据在回话结束（关闭窗口）会被清空。 以 localStorage 的 API 为例 12345678// 写入数据localStorage.setItem('key', 'value')// 读取数据localStorage.getItem('key')// 清除数据localStorage.removeItem('key')// 清空localStorage.clear() 注意Storage 是以键值对的方式存储数据，键值都是字符串！1234localStorage.setItem('null', null)localStorage.getItem('null') // \"null\"localStorage.setItem('obj', { str: '17' })localStorage.getItem('obj') // \"[object Object]\" 建议使用 JSON.stringify() 转换成字符串写入，读取时 JSON.parse() 还原。避免直接写入简单的值类型（比如字符串 ‘10’，数字 10），以免读取的值的类型与写入时不同。 Web SQL 在 2010 年 11 月 18 日，W3C 宣布弃用 Web SQL 数据库规范 IndexedDBIndexedDB 是一种底层 API，用于客户端存储大量结构化数据(包括, 文件/ blobs)。该 API 使用索引来实现对该数据的高性能搜索。相关的第三方库有 PouchDB dexie.js 设备信息访问 注意如下 API 均存在兼容性问题，谨慎使用！！ 网络状态navigator.onLine返回一个布尔值，表示当前浏览器是否在线状态 navigator.connectionnavigator.connection 是只读的，提供一个 NetworkInformation 对象来获取设备的网络连接信息。例如用户设备的当前带宽或连接是否被计量， 这可以用于基于用户的连接来选择高清晰度内容或低清晰度内容。 示例：你当前浏览器检测的网络情况如下 是否在线 有效带宽的估计值 有效的往返时间估计(ms) 连接的有效类型 getNetworkInfo() function getNetworkInfo () { var connection = navigator.connection document.querySelector('dd.online').innerText = 'online: ' + navigator.onLine document.querySelector('dd.downlink').innerText = 'downlink: ' + connection.downlink document.querySelector('dd.rtt').innerText = 'rtt: ' + connection.rtt document.querySelector('dd.effectiveType').innerText = 'effectiveType: ' + connection.effectiveType } navigator.connection.addEventListener('change', function(event) { confirm('network is changed') getNetworkInfo() }) 实现代码如下： html12345678910&lt;dl style=\"background-color: #eee\"&gt; &lt;dt&gt;是否在线&lt;/dt&gt; &lt;dd class=\"online\"&gt;&lt;/dd&gt; &lt;dt&gt;有效带宽的估计值&lt;/dt&gt; &lt;dd class=\"downlink\"&gt;&lt;/dd&gt; &lt;dt&gt;有效的往返时间估计(ms)&lt;/dt&gt; &lt;dd class=\"rtt\"&gt;&lt;/dd&gt; &lt;dt&gt;连接的有效类型&lt;/dt&gt; &lt;dd class=\"effectiveType\"&gt;&lt;/dd&gt;&lt;/dl&gt; js12345678910111213getNetworkInfo()function getNetworkInfo () { var connection = navigator.connection document.querySelector('dd.online').innerText = 'online: ' + navigator.onLine document.querySelector('dd.downlink').innerText = 'downlink: ' + connection.downlink document.querySelector('dd.rtt').innerText = 'rtt: ' + connection.rtt document.querySelector('dd.effectiveType').innerText = 'effectiveType: ' + connection.effectiveType}// 监听网络状态变化navigator.connection.addEventListener('change', function(event) { confirm('network is changed') getNetworkInfo()}) 硬件访问batteryBattery API 提供了有关系统充电级别的信息并提供了通过电池等级或者充电状态的改变提醒用户的事件。 这个可以在设备电量低的时候调整应用的资源使用状态，或者在电池用尽前保存应用中的修改以防数据丢失。 示例：你的设备当前的电池信息如下 navigator.getBattery().then(function(battery) { getBatteryInfo(battery) // 充电状态变化 battery.addEventListener('chargingchange', function() { getBatteryInfo(battery) }) // 电量变化 battery.addEventListener('levelchange', function() { getBatteryInfo(battery) }) // 充电时长变化 battery.addEventListener('chargingtimechange', function() { getBatteryInfo(battery) }) // 放电时长变化 battery.addEventListener('dischargingtimechange', function() { getBatteryInfo(battery) }) }) function getBatteryInfo(battery) { var info = '' info += '是否在充电：' + battery.charging ? '是' : '否' + '\\n' info += '剩余电量：' + battery.level * 100 + '%' + '\\n' info += '充电时间：' + battery.chargingTime + '秒' + '\\n' info += '放电时间：' + battery.dischargingTime + '秒' + '\\n' document.querySelector('.battery-info').innerText = info } 实现代码如下： html1&lt;div class=\"battery-info\" style=\"background-color: #eee;\"&gt;&lt;/div&gt; js123456789101112131415161718192021222324252627navigator.getBattery().then(function(battery) { getBatteryInfo(battery) // 充电状态变化 battery.addEventListener('chargingchange', function() { getBatteryInfo(battery) }) // 电量变化 battery.addEventListener('levelchange', function() { getBatteryInfo(battery) }) // 充电时长变化 battery.addEventListener('chargingtimechange', function() { getBatteryInfo(battery) }) // 放电时长变化 battery.addEventListener('dischargingtimechange', function() { getBatteryInfo(battery) })})function getBatteryInfo(battery) { var info = '' info += '是否在充电：' + battery.charging ? '是' : '否' + '\\n' info += '剩余电量：' + battery.level * 100 + '%' + '\\n' info += '充电时间：' + battery.chargingTime + '秒' + '\\n' info += '放电时间：' + battery.dischargingTime + '秒' + '\\n' document.querySelector('.battery-info').innerText = info} Gyrodeviceorientation 事件在方向传感器输出新数据的时候触发。其数据系传感器与地球坐标系相比较所得，也就是说在设备上可能会采用设备地磁计的数据。 示例：带有方向传感器的设备（手机）上查看 window.addEventListener('deviceorientation', function(event) { getGyroInfo(event) }, true) function getGyroInfo (event) { var info = '' // gamma: 从左到右 info += 'x: ' + event.gamma + '\\n' // beta: 从前到后的运动 info += 'y: ' + event.beta + '\\n' // alpha: 在Z轴上的角度 info += 'z: ' + event.alpha document.querySelector('.Gyro').innerText = info } 实现代码如下： html1&lt;div class=\"Gyro\" style=\"background-color: #eee\"&gt;&lt;/div&gt; js12345678910111213window.addEventListener('deviceorientation', function(event) { getGyroInfo(event)}, true)function getGyroInfo (event) { var info = '' // gamma: 从左到右 info += 'x: ' + event.gamma + '\\n' // beta: 从前到后的运动 info += 'y: ' + event.beta + '\\n' // alpha: 在Z轴上的角度 info += 'z: ' + event.alpha document.querySelector('.Gyro').innerText = info} screen orientation设备屏幕方向发生变化时，screen.orientation 会触发 change 事件，我们可以根据 screen.orientation.type 来判断是横屏还是竖屏。 CSS3 媒体查询也可以查询屏幕方向 示例： @media all and (orientation: portrait) { .screen-orientation::after { content: '(竖屏)'; color: #f40; } } @media all and (orientation: landscape) { .screen-orientation::after { content: '(横屏)'; color: #f4f; } } screen.orientation.addEventListener('change', function() { getScreenOrientation() }) function getScreenOrientation() { document.querySelector('.screen-orientation').innerText = '屏幕方向是：' + screen.orientation.type + ' ' } getScreenOrientation() 实现代码如下： css123456789101112@media all and (orientation: portrait) { .screen-orientation::after { content: '(竖屏)'; color: #f40; }}@media all and (orientation: landscape) { .screen-orientation::after { content: '(横屏)'; color: #f4f; }} html1&lt;div class=\"screen-orientation\"&gt;&lt;/div&gt; js1234567screen.orientation.addEventListener('change', function() { getScreenOrientation()})function getScreenOrientation() { document.querySelector('.screen-orientation').innerText = '屏幕方向是：' + screen.orientation.type + ' '}getScreenOrientation() devicelight环境光传感器数据变化时，触发 window 的 devicelight 事件，我们从 event 的 value 属性获得环境光的强度。 当前只有 Edge Firfox for Android 支持，但我手机上试了，并没有成功！！！ 示例： window.ondevicelight = function(event) { document.querySelector('.devicelight').value = event.value; } 实现代码如下： html123456&lt;progress class=\"devicelight\" value=\"0\"&gt;&lt;/progress&gt;&lt;script&gt; window.ondevicelight = function(event) { document.querySelector('.devicelight').value = event.value; }&lt;/script&gt; userproximity距离传感器的数据变化时，触发 window 的 userproximity 事件，通过事件的 event.near 属性可以知道是否正在接近传感器 目前只有 Firefox 支持，但我的电脑没有距离传感器 示例： window.addEventListener('userproximity', function(event) { if (event.near) { document.querySelector('.userproximity').innerText = '正在靠近传感器' } else { document.querySelector('.userproximity').innerText = '正在远离传感器' } }) 实现代码如下： html1&lt;div class=\"userproximity\"&gt;&lt;/div&gt; js1234567window.addEventListener('userproximity', function(event) { if (event.near) { document.querySelector('.userproximity').innerText = '正在靠近传感器' } else { document.querySelector('.userproximity').innerText = '正在远离传感器' }}) geolocation获取当前的位置 12345678910111213141516171819202122232425262728293031323334353637383940414243if (navigator.geolocation) { // 获取当前地理位置坐标 navigator.geolocation.getCurrentPosition(success, error, option) // 获取陈成功 callback function success(position) { const { coords: { altitudeAccuracy, // 海拔精度 altitude, // 海拔高度 accuracy, // 位置精度（米） longitude, // 经度 latitude, // 维度 heading, // 移动的方向（度），正北是 0 ，顺时针。不移动时 NaN speed // 移动速度（米/秒） }, timestamp // 返回数据的时间 } = position } // 获取失败 callback function error(err) { switch (err.code) { case err['PERMISSION_DENIED']: console.error('用户拒绝授权！') break; case err['POSITION_UNAVAILABLE']: console.error('获取位置失败！') break; case err['TIMEOUT']: console.error('获取位置超时！') break; default: console.error(err.message || '未知错误') } } // 配置 var option = { enableHighAccuracy: false, // 获取高精度位置，比如支持 GPS 的设备 timeout: Infinity, // 等待返回数据的时长（毫秒） maximumAge: 0 // 缓存获取的位置，0 就是要求获取最新位置（毫秒） }} else { // 不支持} 监听位置变化 1234// 监听位置变化，位置变化的时候触发var id = navigator.geolocation.watchPosition(success[, error[, options]])// 取消监听navigator.geolocation.clearWatch(id) 提示：1.Chrome、iOS 等相继限制非安全域的定位请求，我们建议您升级网站到HTTPS协议，Chrome 仍然支持对 localhost 域名的支持，这方便了开发2.navigator.geolocation 获取的是 GPS 经纬度坐标，在地图上使用需要转成对应的地图经纬度坐标。 网络访问XMLHttpRequest level 2fetchWebSocket桌面通知Notification构造函数 Notification 用于发布桌面消息通知。参数解析如下： 12345678910/** * @param title 一定会被显示的通知标题 * @param options.dir 文字的方向；它的值可以是 auto（自动）, ltr（从左到右）, or rtl（从右到左） * @param options.lang 指定通知中所使用的语言。这个字符串必须在 BCP 47 language tag 文档中是有效的。 * @param options.body 通知中额外显示的字符串 * @param options.tag 赋予通知一个ID，以便在必要的时候对通知进行刷新、替换或移除。 * @param options.icon 一个图片的URL，将被用于显示通知的图标。 * */new Notification(title[, options]) 请求权限首先要请求用户许可桌面通知，用户同意后才能弹出通知。调用 Notification.requestPermission() 方法后浏览器会弹出提示框，返回一个 Promise ，值是 default (用户关闭了提示框)， granted (用户允许了)， denied (用户拒绝了)。如果值是非 default ，浏览器会记住用户的选择。再次调用该方法不再弹出提示。 实例方法关闭通知 notification.close() 实例事件 事件 描述 click 处理 click 事件的处理。每当用户点击通知时被触发。 show 处理 show 事件的处理。当通知显示的时候被触发。 close 处理 close 事件的处理。当用户关闭通知时被触发。 error 处理 error 事件的处理。每当通知遇到错误时被触发。 示例： 请求权限 测试通知 var permission = Notification.permission function requestPermission() { Notification.requestPermission().then(res => { res === 'granted' && alert('用户允许桌面通知') res === 'denied' && alert('用户拒绝桌面通知') res === 'default' && alert('用户还没决定要不要允许桌面通知') permission = res }) } function notice() { if (permission !== 'granted') { return alert('用户没有允许桌面通知') } new Notification('来自 ShineKidd 的问候', { body: '欢迎访问 ' + location.host, icon: 'https://octodex.github.com/images/mountietocat.png' }) } chrom 每次最多只显示 3 个通知，多于 3 个通知时。前一个通知关闭，才显示下一个通知。 实现代码如下： html123456789101112131415161718192021222324&lt;div style=\"background-color: #eee\"&gt; &lt;button onclick=\"requestPermission()\"&gt;请求权限&lt;/button&gt; &lt;button onclick=\"notice()\"&gt;测试通知&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var permission = Notification.permission function requestPermission() { Notification.requestPermission().then(res =&gt; { res === 'granted' &amp;&amp; alert('用户允许桌面通知') res === 'denied' &amp;&amp; alert('用户拒绝桌面通知') res === 'default' &amp;&amp; alert('用户还没决定要不要允许桌面通知') permission = res }) } function notice() { if (permission !== 'granted') { return alert('用户没有允许桌面通知') } new Notification('来自 ShineKidd 的问候', { body: '欢迎访问 ' + location.host, icon: 'https://octodex.github.com/images/mountietocat.png' }) }&lt;/script&gt; 多线程Web WorkersWeb 应用程序可以通过 Web Workers 在与主线程分离的后台线程中运行一个脚本操作。这样做的好处是可以在独立的线程中执行费时的处理任务，从而允许主（通常是UI）线程不被阻塞/放慢。 — The End —","link":"/html/2017/02/24/"},{"title":"substr, slice, substring 傻傻分不清","text":"js 提供了 3 个截取字符串的 API slice, substring, substr，这 3 个 API 到底有什么区别，该用哪个呢？老是傻傻分不清，赶紧记下来了。 基本用法sliceslice 可接受 2 个参数，第二个参数可选。第一个参数表示截取开始的位置，第二个参数表示截取结束的位置（但不包含） slice1234'abcdefg'.slice(1) // \"bcdefg\"'abcdefg'.slice(1, 5) // \"bcde\"// 当第一个大于第二个，返回空字符串'abcdefg'.slice(5, 1) // \"\" 参数为负数时，各个参数加字符串的长度转成正数，再计算 slice 参数小于 01234567891011'abcdefg'.slice(-1) // 相当于 'abcdefg'.slice(6) // \"g\" 'abcdefg'.slice(1, -5)// 相当于 'abcdefg'.slice(1, 2) // \"b\"'abcdefg'.slice(-1, -5) // 相当于 'abcdefg'.slice(6, 2) // \"\" substringsubstring 可接受 2 个参数，第二个参数可选。第一个参数表示截取开始的位置，第二个参数表示截取结束的位置（但不包含），这与 slice 非常相似 substring 12'abcdefg'.substring(1) // \"bcdefg\"'abcdefg'.substring(1, 5) // \"bcde\" 当参数是负数时，会把参数转成 0，当第一个参数大于第二个参数时，会交换两个参数的位置 substring 参数小于 01234567'abcdefg'.substring(-1) // 相当于 'abcdefg'.substring(0) // \"abcdefg\"'abcdefg'.substring(-1, -5) // 相当于 'abcdefg'.substring(0, 0) // \"\" substring 第一个参数小于第二个参数123'abcdefg'.substring(5, 1) // 相当于 'abcdefg'.substring(1, 5) // \"bcde\" substrsubstr 可接受 2 个参数，第二个参数可选。第一个参数表示截取开始的位置，第二个参数表示截的字符串个数 substr12'abcdefg'.substr(1) // \"bcdefg\"'abcdefg'.substr(1, 5) // \"bcdef\" 当参数是负数时，第一个参数与字符串长度相加转成正数，第二个参数转成 0 substr 参数小于 01234567891011'abcdefg'.substr(-1)// 相当于'abcdefg'.substr(6) // \"g\"'abcdefg'.substr(-1, 5) // \"g\"// 相当于'abcdefg'.substr(6, 5) // \"g\"'abcdefg'.substr(1, -5) // \"bcdef\"// 相当于'abcdefg'.substr(1, 0) // \"\" 结论 共同点 从原字符串取出子字符串并返回，不改变原字符串 可接受 1 个或 2 个索引值作为参数 差异性 接受 1 个参数时 slice 和 substr 表现一致 接受 2 个参数时，slice substring 截取的范围是左闭右开区间 参数 1 小于参数 2 时，substring 交换两个参数的位置再运算，slice 直接返回空字符串 参数小于 0 时，substring 会把参数转为 0 ，slice 对两个参数的处理和 substr 对第一个参数一致，都是加上字符串长度再运算，substr 第二个参数会转成 0 — The End —","link":"/js/2017/06/17/"},{"title":"CSS 盒模型及 DOM 相关尺寸获取","text":"本文主要记录使用 JS 获取盒模型的相关数据 回顾盒模型 老版本的 IE 的盒模型的 width、height 包括了 padding 和 border 使用 CSS 的 box-sizing 属性可以可以控制盒子 width、height 的计算方式。 box-sizing: content-box —— 标准盒模型box-sizing: border-box —— IE 盒模型（为了方便计算布局，我们一般采用这个） clientHeight、clientWidthElement.clientHeight 、Element.clientWidth 返回一个正整数，表示元素节点的高度盒宽度。包括 padding 部分，但步包括 border 。如果是小数，会四舍五入。行内元素返回 0 html 标签的 clientHeight 最高默认是 window.innerHeight clientLeft 、clientTopElement.clientLeft 属性等于元素节点左边框（left border）的宽度（单位像素），如果没有设置左边框，或者是行内元素（display: inline），该属性返回 0 。该属性总是返回整数值，如果是小数，会四舍五入。 Element.clientTop 同理表示是上边框的宽度 scrollHeight、scrollWidthElement.scrollHeight 属性返回一个整数值（小数会四舍五入），表示当前元素的总高度（单位像素），包括溢出容器、当前不可见的部分(overflow: hidden)。它包括 padding，但是不包括border、margin 以及水平滚动条的高度（如果有水平滚动条的话），还包括伪元素（::before或::after）的高度。 Element.scrollWidth 同理 scrollLeft、scrollTopElement.scrollLeft 属性表示当前元素的水平滚动条向右侧滚动的像素数量，Element.scrollTop 属性表示当前元素的垂直滚动条向下滚动的像素数量。对于那些没有滚动条的网页元素，这两个属性总是等于 0。 该属性可写， offsetHeight、offsetWidthElement.offsetHeight 属性返回一个整数，表示元素的 CSS 垂直高度（单位像素），包括元素本身的高度、padding 和 border，以及水平滚动条的高度（如果存在滚动条）。 Element.offsetWidth 属性表示元素的 CSS 水平宽度（单位像素），其他都与 Element.offsetHeight 一致。 这两个属性都是只读属性，只比 Element.clientHeight 和 Element.clientWidth 多了边框的高度或宽度。如果元素的 CSS 设为不可见（比如display: none;），则返回0。 offsetLeft、offsetTop这两个属性和定位相关。先要了解另一个属性 Element.offsetParent Element.offsetParent 返回的是 Element 的带有定位（position 是 relative、absolute、fixed）的父（爷）元素。 Element 是不可见的（display: none），或者位置是固定的（position: fixed），则 Element.offsetParent 属性返回 null。 Element.offsetTop 和 Element.offsetLeft 就是 offsetParent 元素计算的。Element.offsetLeft 返回当前元素左上角相对于 Element.offsetParent 节点的水平位移，Element.offsetTop 返回垂直位移，单位为像素。通常，这两个值是指相对于父节点的位移。 getComputedStyleElement.style.xx 这种方式可对元素设置内联样式，也（只）能获取到内联样式 window.getComputedStyle(Element) 方法，可以获取到元素渲染之后的的所有样式数据，而且是精确的数据。 — The End —","link":"/js/2017/12/09/"},{"title":"设备像素比 devicePixelRatio","text":"window.devicePixelRatio 是设备上物理像素和设备独立像素 (device-independent pixels (dips)) 的比例。 通过 windo.screen.width windo.screen.height 可分别获取当前设备屏幕的宽度和高度。单位是像素（px）。这个尺寸是独立像素大小。 看看常见手机设备该尺寸大小 IOS 手机 屏幕尺寸 屏幕分辨率 ppi 独立像素 设备像素比（dpr） iphone 4 3.5英寸 640*960 362 320*480 2 iphone 5 4英寸 640*1136 362 320*568 2 iphone 6 4.7英寸 750*1334 362 375*667 2 iphone 6plus 5.5英寸 1242*2208 401 441*736 3 Android 手机 屏幕尺寸 屏幕分辨率 ppi 独立像素 设备像素比（dpr） readmi1 4.7英寸 720*1280 312 360*640 2 xiaomi5 5.15英寸 1080*1920 428 360*640 3 分辨率 是屏幕水平方向和垂直方向的物理像素数量。 PPI 是每英寸物理像素的数量，反映像素的密度。所以，PPI 越大，屏幕显示越细腻 在没有缩放的情况下，独立像素就是 CSS 像素，dpr 为 3 ，就是 3*3 个物理像素来显示一个 css 像素。 — The End —","link":"/js/2017/09/09/"},{"title":"js 函数中的 arguments 对象","text":"由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是 arguments 对象的由来。arguments 对象是所有（非箭头）函数中都可用的局部变量，它是一个类数组。你可以使用 arguments 对象在函数中引用函数的参数。此对象包含传递给函数的每个参数. arguments正常模式下，arguments对象可以在运行时修改。 123456function f(a, b) { arguments[0] = 3 arguments[1] = 2 return a + b}f(1, 1) // 5 严格模式下，arguments对象是一个只读对象，修改它是无效的，但不会报错。 1234567function f(a, b) { 'use strict' arguments[0] = 3 arguments[1] = 2 return a + b}f(1, 1) // 2 arguments 转数组arguments 对象是一个类数组，length 属性是实际参数的个数 functionName 也有 length 属性，但那是形参的个数 1234567891011// 法一var args = Array.apply(null, arguments)// 法二var args = Array.prototype.slice.call(arguments)// 法三let args = [...arguments]// 法四let args = Array.from(arguments) arguments.callee通过 arguments.callee，达到调用函数自身的目的，常见于匿名函数递归调用，递归调用容易栈溢出（stack overflow）错误 1234567// 阶乘函数function factorial(num) { return num &gt; 1 ? arguments.callee(num - 1) * num : 1}factorial(5) // 120 这个属性在严格模式下已被禁用，因为 JavaScript 解释器不可能实现内联和尾递归优化（尾调优化可以避免栈溢出错误，目前没有浏览器支持）。 尾递归优化123456function factorial(num, total = 1) { return num &gt; 1 ? factorial(num - 1, total * num) : total}factorial(50000) // Infinity 另外一个主要原因是递归调用会获取到一个不同的 this 值 this 值改变123456789101112var global = thisfunction f (n) { if (n) { return arguments.callee(n - 1) } if (this !== global) { console.log('This is: ' + this); } else { console.log('This is the: ' + global); }}f(3) // This is: [object Arguments] arguments.callee.callerarguments.callee.caller 就是 Function.caller 返回一个函数的引用，该函数调用了当前函数。严格模式 callee caller 均下不可。 123(function() { console.log(arguments.callee.caller)})() // null 1234567function foo() { console.log(foo.caller)}function bar() { foo()}bar() // ƒ bar() { foo() } — The End —","link":"/js/2017/09/16/"},{"title":"前端下载文件的困扰","text":"最近在使用腾讯云对象存储。。。下载一张图片、一个 pdf 、一首 mp3、一本 txt 小说。发现 Chrome FireFox 总是“很人性”的主动在标签中“打开了包装”！我要的是保存！是下载！ f**k ！！前端如何下载文件？？？ Content-Disposition 响应头对目标请求设置响应头 Content-Disposition 来规范浏览器对文件资源的处理方式，这是最佳方案！ Content-Disposition 两种值 inline 内容以内联的形式（即网页或者页面的一部分）展示 attachment; filename=\"dog.jpg\" 内容以附件的形式下载并保存到本地。filename 用于指定下载文件名，可选 目前 Content-Disposition 有两处用途： 作为消息主体中的响应头：就是上述这种情况 作为 multipart body 中的消息头：form 表单的 enctype 属性设置为 multipart/form-data 时，Content-Disposition 出现在请求体 body 中 腾讯云存储设置 Content-Disposition 单个文件的设置方法 《自定义 Headers》 [doc] 全局设置方法 《HTTP Header 配置》 [doc] download 属性使用 a 标签 的 download 属性，浏览器检测到该属性会执行下载操作。 12&lt;!-- target 属性是防止不支持 download 属性的浏览器不会重载当前页面，role 属性是告知辅助设备，当前标签的作用是按钮 --&gt;&lt;a href=\"http://www.example.com/a.jpg\" download=\"dog.jpg\" target=\"_blank\" role=\"button\"&gt;下载图片&lt;/a&gt; 可指定下载文件保存时的文件名，值是可选的 注意 这个属性的支持性不好 查看支持[doc] 文件资源跨域时，用 Chrome 65、FireFox 测试，仍然是直接浏览器打开 ajax 下载1234567891011121314151617function download(url = 'http://image.com/dog.jpg', mime = 'image/jpg') { let xhr = new XMLHttpRequest() xhr.open('GET', url, true) xhr.responseType = 'blob' // arraybuffer 也可以 xhr.onload = function(e) { let blob = new Blob([xhr.response], { type: mime }) let objectUrl = URL.createObjectURL(blob) let anchor = document.createElement('a') anchor.download = '' anchor.href = objectUrl anchor.click() setTimeout(function () { // 内存回收 URL.revokeObjectURL(anchor.href) }, 60) } xhr.send()} 注意使用 ajax 下载存在跨域的问题，也不能从 https 下 http 域名的文件。 canvas 输出图片1234567891011121314151617function download(url, mime = 'image/png') { let img = new Image() img.crossOrigin = 'anonymous' img.onload = function() { let canvas = document.createElement('canvas') canvas.width = img.naturalWidth canvas.height = img.naturalHeight let ctx = canvas.getContext('2d') ctx.drawImage(img, 0, 0) let dataURL = canvas.toDataURL(mime) let a = document.createElement('a') a.download = '' a.href = dataURL a.click() } img.src = url} 最后推荐一个可以保存文件的库: FileSaver — The End —","link":"/js/2017/12/16/"},{"title":"ES6 新特性概览","text":"JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了，ECMAScript 6.0（以下简称 ES6）。在 Babel 这款优秀的 ES6 转码器的帮助下，我们可以放心的使用新的 ES6 语法编写兼容性良好的 web 应用了。我们还有什么理由不去跟进 ES6 ？赶紧看看 ES6 带来了哪些新的语法特性吧！ let constES5 只有两种声明变量的方式 var function，ES6 新增 4 种方式 let const import class 不存在变量提升ES5 变量提升123console.log(a, fn) // undefined ƒ fn() {}var a = 1function fn() {} ES6 变量不提升1234console.log(b) // Uncaught ReferenceError: b is not definedconsole.log(c) // Uncaught ReferenceError: c is not definedlet b = 2const c = 3 不可重复声明123456789// example 1var a = 1let a = 2 // Uncaught SyntaxError: Identifier 'a' has already been declared// example 2let bvar b // Uncaught SyntaxError: Identifier 'b' has already been declared// example 3let clet c // Uncaught SyntaxError: Identifier 'c' has already been declared 用 const 声明一个常量，同 let 一样不可重复声明，还有以下特点12345678// 声明时必须赋值const a // Uncaught SyntaxError: Missing initializer in const declaration// 申明的变量不可重新赋值const b = 0b += 1 // Uncaught TypeError: Assignment to constant variable.const rect = []rect.push(1, 2, 3) // [1, 2, 3]rect = {} // Uncaught TypeError: Assignment to constant variable. 暂时性死区注意报的不是 Uncaught ReferenceError 12345let a = 1if (true) { a = 4 // Uncaught SyntaxError: Identifier 'a' has already been declared let a} 块级作用域类似函数作用域，块内定义的变量，块外访问报引用错误 12345678{ var a = 3 let b = 1 const c = 2}console.log(a) // 3console.log(b) // Uncaught ReferenceError: b is not definedconsole.log(c) // Uncaught ReferenceError: c is not defined for 循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域 123456for (let i = 0; i &lt; 3; i++) { let i = 5 console.log(i) // 打印 3 次 5}// 循环外面访问不到变量 iconsole.log(i) // Uncaught ReferenceError: i is not defined 模板字符串123456789// 使用反引号(`)包裹字符串，字符串中的双引号，单引号相互嵌套而不需要转义let str1 = `say: 'hello \"world\" !'`// 使用花括号插入变量或表达式，比拼接字符串优雅let str2 = `are you ${ 1 &gt; 3 ? 'ok' : 'sure' } ?`// 支持换行let str3 = `&lt;div&gt; &lt;span&gt; ${parseInt('1.324')} &lt;/span&gt; &lt;/div&gt; ` SymbolES6 引入了一种新的原始数据类型Symbol，表示独一无二的值, 它是一种类似于字符串的数据类型。123456789101112let s = Symbol()s // Symbol()typeof s // \"symbol\"let key1 = Symbol('key')let key2 = Symbol('key')key1 === key2 // falselet o = { [key1]: 1, [key2]: 2}o // {Symbol(key): 1, Symbol(key): 2}o[key1] // 1 Set MapSetSet 是一种新的据结构t，类似数组，但里面的成员是唯一的，可以和数组互转，实例没有提供 get 方法12345678910111213141516// 创建 setlet dessert = new Set('ABCC') dessert // Set(3) {\"A\", \"B\", \"C\"}// 添加相同的项dessert.add('pie')dessert.add('pie') // Set(4) {\"A\", \"B\", \"C\", \"pie\"}dessert //Set(4) { 'A', 'B', 'C', 'pie' }dessert.size // 4dessert.has('A') // truedessert.delete('A') // true// 遍历dessert.forEach( item =&gt; console.log(item) // B C pie) // 清空 set dessert.clear() Set Array 互转123const set = new Set([1, 2, 3, 3, 3])[...set] // [1, 2, 3]Array.from(new Set([1, 2, 3, 3, 3])) // [1, 2, 3] MapMap 是一种新的数据结构。它类似于对象，也是键值对的集，但它的键不再局限于字符串123456789const map = new Map()const key = { a: 1 }map.set(key, { b: 2 }) // Map(1) {{…} =&gt; {…}} 可以链式操作map.get(key) // {b: 2}map.size // 1map.get('key') // undefinedmap.has(key) // truemap.delete(key) // truemap.clear() 传入二维数组创建一个 map 实例123456789101112new Map([ [{ a: 1 }, { b: 2 }], [{ c: 3 }, { d: 4 }]]) // Map(2) {{…} =&gt; {…}, {…} =&gt; {…}}// 等价于如下操作，利用的数组解构let m = new Map()[ [{ a: 1 }, { b: 2 }], [{ c: 3 }, { d: 4 }]].forEach(([key, value]) =&gt; { m.set(key, value)}) 对象解构数组要求一一对应，否则赋值 undefined1234let [a, b, c] = [1, 2, 3, 4]console.log(a, b, c) // 1 2 3let [d, [e], f] = [1, [2]]console.log(d, e, f) // 1 2 undefined 对象要求有对应的键，且键对应的值不是 undefined 才能赋值成功1234567// 指定新的变量与键名不同let { cat, dog: DOG } = { cat: 'cat', dog: 'dog' }console.log(cat, DOG) // cat dog// 赋值是 undefined 时取默认值function getDuck() { return undefined }let { pig = 'pig', duck = 'duck' } = { duck: getDuck() }console.log(pig, duck) // pig duck 对象属性12345678910111213141516// 当属性名为变量名, 属性值为变量的值，可简写let name = 'foo', age = 18let gay = { name, age } // {name: \"foo\", age: 18}// 属性为方法时，可以简写let obj = { name: 'bar', say() { console.log(`I am ${this.name}`) }}// 字面量定义对象时，键可以是变量或字符串let animal = 'wolf'let des = { [animal]: `is a ferocious wilderness`, ['danger coefficient']: 8} 展开(剩余操作)算符123456789101112// 展开对象let a = { a: 1, b: 3 }let obj = { c: 4, ...a } // {c: 4, a: 1, b: 3}// 展开数组let rect1 = [1, 2, 3]let rect2 = [...rect1, 4, 5, 6] // (6) [1, 2, 3, 4, 5, 6]// 展开字符串let str = 'abc'let strArray = [...str] // (3) [\"a\", \"b\", \"c\"]// 解构运算let { a, b, ...other } = { a: 1, b: 2, c: 3, d: 4 }console.log(a, b, other) // 1 2 {c: 3, d: 4} Object 新增 APIis12345678// ES5 的比较运算有些让人琢磨不透['3'] == 3 // true'' == 0 // true+0 === -0 // trueNaN === NaN // false// ES6 同值相等，严格相等比较法，Map，Set 的键是这样比较是否重复的Object.is(NaN, NaN) // trueObject.is(+0, -0) // false assign多用于为对象添加属性和方法，浅拷贝克隆对象，合并多个对象1234567891011// 对象的合并let target = { a: 1 }, source1 = { b: 2 }, source2 = { c: 3 }Object.assign(target, source1, source2) // {a: 1, b: 2, c: 3}// 目标对象如果是 null undefined 将会报错Object.assign(null, source1) // Uncaught TypeError: Cannot convert undefined or null to object// 源对象是 null undefined NaN Boolen Number 都会被忽略Object.assign(target, null, undefined, NaN, true, false, 0) === target // true// 源对象是字符串Object.assign({}, 'abc') // {0: \"a\", 1: \"b\", 2: \"c\"}// 注意，同名属会被性替换，它不是 deep-assignObject.assign({ b: { name: 'bar' } }, source1) // {b: 2} setPrototypeOf getPrototypeOfES5 通过非标准属性 proto 来读取和设置当前对象的 prototype 对象1234567891011121314151617181920let drink = { getDrink() { return 'coffe' }}let fruit = { getFruit() { return 'apple' }}let price = { coffe: '$2.5', apple: '$1.2' }// ES5 创建 prototype 对象// 1.Object.create 创建let eat = Object.create(price)eat.__proto__ === price // true// 2.字面量方式创建eat = { __proto__: drink}eat.__proto__ === drink // true// ES5 读写 prototype 对象eat.getDrink() // \"coffe\"eat.__proto__ = fruiteat.getFruit() // \"apple\" ES6 提供了两个标准的 API 来实现12345// ES6 设置 prototype 对象Object.setPrototypeOf(eat, { say() { console.log('wo~~') } })eat.say() // wo~~// ES6 获取 prototype 对象Object.getPrototypeOf(eat) // {say: ƒ} superthis 关键字总是指向函数所在的当前对象，super 关键字则指向当前对象的原型对象12345678910const proto = { drink: 'beer'}const eat = { getDrink() { return super.drink }}Object.setPrototypeOf(eat, proto)eat.getDrink() // \"beer\" 注意super 关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。目前，只有对象方法的简写法中可以使用 super 1234567const eat = { drink: super.drink, // 报错 beer: () =&gt; super.drink, // 报错 water: function() { // 报错 return super.drink }} Function 新增语法函数参数默认值1234function eat(dessert = 'cake', drink = 'coffe') { console.log(dessert, drink)}eat() // cake coffe 函数参数构12345678910// 解构并指定默认值function breakfast (dessert, { drink = 'milk', fruit }) { console.log(dessert, drink, fruit)}breakfast('cake', { fruit: 'apple' }) // cake milk apple// 另一种指定默认值的方式是对解构体指定默认值，一旦传入解构体，则不再取默认值function dinner(dessert, { drink, fruit } = { drink: 'milk', fruit: 'apple' }) { console.log(dessert, drink, fruit)}dinner('cake', { fruit: 'apple' }) // cake undefined apple 函数参数使用展开运算符1234function eat(dessert, ...other) { console.log(dessert, other)}eat('cake', 'coffe', 'apple') // cake (2) [\"coffe\", \"apple\"] 函数名123456789// ES5 已经支持 function 声明的函数获取函数名，ES6 纳入标准let tea = function () { }console.log(f2.name) // tea// 优先级let foo = function bar() { }console.log(foo.name) // barconsole.log(bar) // Uncaught ReferenceError: bar is not defined// bind返回的函数foo.bind({}).name // \"bound bar\" 箭头函数123456789101112131415161718192021222324252627// 简化书写，function foo (a, b) { return a + b } 可如下书写let foo = (a, b) =&gt; a + b// 一个参数时可省略括号let foo = a =&gt; Number(a)// 无法在函数内使用 arguments 对像let bar = (...args) =&gt; { console.log(args) // (3) [1, 2, 3] console.log(arguments) // Uncaught ReferenceError: arguments is not defined}bar(1, 2, 3) // 箭头函数根本没有自己的 this，导致内部的 this 就是外层代码块的 thisvar age = 18var obj = { sex: 'male', bar: function () { setTimeout(() =&gt; { console.log(this.sex, this.age) // this 指向 obj }, 100) }, foo: function () { setTimeout(function () { console.log(this.sex, this.age) // this 指向 window }, 100) }}obj.bar() // male undefinedobj.foo() // undefined 18 ProxyProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截。一种支持 13 种拦截操作 PromiseIterator以下数据具备原生 Iterator 接口，可以使用 for … of 遍历Array, Set, Map, String, 类数组（DOM NodeList, arguments） GeneratorClass定义一个类12345678910class Chef { constructor(food) { // 此方法在创建实例的时候会自动执行 this.food = food } cook() { // 定义方法，之前不用逗号隔开 return this.food }}let chef = new Chef('tomato')chef.cook() // tomato getter setter在类的内部可以使用 get 和 set 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为12345678910111213141516171819class Chef { constructor(food) { this.food = food this.dish = [] } get menu() { return this.dish } set menu(dish) { this.dish.push(dish) } cook() { return this.food }}let chef = new Chef();chef.menu = 'tomato';chef.menu = 'eggs';console.log(chef.menu); // [ 'tomato', 'eggs' ] static定义类的静态方法 1234567class Chef { constructor() { } static cook(food) { return food }}Chef.cook('tomato') // \"tomato\" extends父类的静态方法，可以被子类继承。123456789101112131415161718192021222324252627class Animal { constructor (name) { this.name = name this.des = 'sly' } intro() { return `${this.name} is ${this.des}` } static say() { return 'hello' }}class Fox extends Animal { constructor(name) { super(name) } static shout() { return super.say().toUpperCase() }}// 子类直接调用父类的静态方法Fox.say() // \"hello\"// 子类的静态方法上调用父类静态方法Fox.shout() // \"HELLO\"let fox = new Fox('jarry')// 子类继承父类属性方法fox.intro() // \"jarry is sly\" import exportES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案 export./module/breakfast.js1234567// 默认导出export default { chef: 'jarry', breakfast(drink = 'beer') { console.log(`Today's breakfast is ${drink} !`) }} ./module/chef.js12345678let chef = 'tom'function dinner(fruit = 'banana') { console.log(`Today's dinner is ${fruit} !`)}// 单个导出export let dessert = 'cake'// 导出重命名export { chef, dinner as supper } import1234567891011// 导入并并重命名import morning from './module/breakfast.js'morning.chef // \"jarry\"morning.breakfast() // \"Today's breakfast is beer !\"// 全部导入import * as night from './module/dinner'night // {dessert: \"cake\", chef: \"tom\", supper: f dinner() } // 按需导入import { dessert, supper } from './module/dinner'dessert // ”cake“supper() // \"Today's dinner is banana !\" — The End —","link":"/js/2017/08/12/"},{"title":"html5 新增的 API","text":"HTML 5 新增了一些有意思的 API，本文介绍基本用法并附上部分 demo 新的 DOM 选择器getElementBy之前我们是这样选取 DOM 的 123document.getElementById('my_form')document.getElementsByTagName('from')document.getElementsByClassName('.form') querySelector现在有了媲美 jQuery 的选择器 简单12345678910111213141516// 标签document.querySelector('DIV')// iddocument.querySelector('#my_form')// 类名 document.querySelector('.active')// 子代document.querySelectorAll('ul .item')document.querySelectorAll('ul &gt; .item')// 兄弟document.querySelectorAll('div + p')document.querySelectorAll('div ~ p')// 交集document.querySelector('span.active')// 并集document.querySelectorAll('A, DIV, SPAN') 伪类过滤12345678// 不通过验证的表单元素document.querySelectorAll('form :invalid')// 没有 .ingnor 类名的 spandocument.querySelectorAll('span:not(.ignore)')// 空的 divdocument.querySelectorAll('div:empty')// 获得焦点的元素document.querySelectorAll(':focus') 选择属性123456// 属性以 https:// 开头的 a 元素document.querySelector('a[href^=\"https://\"]')// 属性以 .com 结尾的 a 元素document.querySelector('a[href$=\".com\"]')// 属性包含 zhulu 的元素document.querySelector('[href*=\"zhulu\"]') 标签名不区分大小写，在元素节点上也可以调用上述两个方法。querySelectorAll 的返回结果不是动态集合，不会实时反映元素节点的变化。与 document.getElementsBy 方法不同 操作类名classListDOM 上部署了 classList 属性，可以访问 DOM 所有的类名，并且可以操作该属性 12var div = document.querySelector('div')div.classList // DOMTokenList(2) [\"item\", \"active\", value: \"item active\"] add()增加类名，支持多个参数，逗号分隔1div.classList.add('animated') remove()移除类名，支持多个参数，逗号分隔 1div.classList.remove('active') item()返回指定索引位置的 class 1div.classList.item(0) contains()判断某个类名是否存在 1var isAnimated = div.classList.contains('animated') // 返回布尔值 toggle()删除添加之间切换一个类名 1div.classList.toggle('animated', !isAnimated) 访问历史 APIhistory 对象 HTML5 之前含有的 API forward() back() go()12345678// 控制浏览历史前进一个记录window.history.forward()// 控制浏览历史后退一个记录window.history.back()// 控制浏览历史跳转到指定的一个记录，0 是刷新，正整数是前进，负整数是后退window.history.go(n) 从 HTML5 开始——提供了对 history 栈中内容的操作。 pushState12345678/** * 这将使浏览器地址栏显示为 url，但并不会导致浏览器加载对应的页面 * 甚至不会检查页面是否存在。 * @param stateObj 在 onpopstate 事件中通过 event.state 能获取到该对象 * @param title 历史纪录的标题，目前浏览器忽略该参数 * @param url 可选，可以是相对路径、绝对路径（同相对路径一样处理）、query，不能是其他域名的 url */window.history.pushState(stateObj, title [, url]) replaceState1234/** * 修改当前激活的历史记录条目，参数和 pushState 一样 */window.history.replaceState(stateObj, title [, url]) onpopstate调用 history.pushState() 或者 history.replaceState() 不会触发 popstate 事件. popstate 事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮(或者在 JavaScript 中调用 history.back()、history.forward()、history.go() 方法) 123window.addEventListener('popstate', function(even) { console.log(event.state)}) 注意当网页加载时,各浏览器对 popstate 事件是否触发有不同的表现, Chrome 和 Safari 会触发 popstate 事件, 而 Firefox 不会页面刷新（history.go(0)、location.reload()、真实的页面跳转）会导致 js 从新解析，也不会触发 popstate 事件 全屏 APIElement.requestFullscreen() 方法用于发出异步请求使元素进入全屏模式，全屏的元素背景色默认是黑色。 requestFullscreen123document.querySelector('video').addEventListener('dblclick', function(e) { e.target.requestFullScreen()}) 浏览器兼容性：需要前缀 webkit、moz、ms 调用此 API 并不能保证元素一定能够进入全屏模式。如果元素被允许进入全屏幕模式，document 对象会收到一个 fullscreenchange 事件，通知调用者当前元素已经进入全屏模式。如果全屏请求不被许可，则会收到一个 fullscreenerror 事件。只有包含在顶层文档（top-level document）内部的标准HTML元素、&lt;svg&gt;元素和&lt;math&gt;元素，以及拥有 allowfullscreen 属性的 iframe 的内部元素可以进入全屏模式。这意味着在 frame 内部的元素，以及 object 的内部元素不能进入全屏模式 拖放操作可以从桌面拖拽文件到浏览器的的 DOM ，也可以直接拖拽网页中的文字、图片、DOM 到 DOM。 拖拽属性含有 draggable=”true” 属性的 DOM 是可拖拽的 拖拽事件 事件 描述 ondragstart 拖拽开始，由被拖拽的对象触发 ondrag 拖拽过程中，由被拖拽的对象持续触发 ondragend 拖拽结束，由被拖拽的对象触发 ondragenter 进入放置区 DOM，由放置区 DOM 触发 ondragover 在放置区 DOM 内，由放置区 DOM 持续触发 ondragleave 离开放置区 DOM ，由放置区 DOM 触发 ondrop 在放置区释放对象，由放置区 DOM 触发 示例下面是拖拽的一个例子，可以拖拽文字、文件、div 到放置区 .target { width: 200px; margin: 0 auto 10px; background: #999; text-align: center; } .target.active { background: yellow; color: red; } .dropzone { width: 500px; min-height: 200px; margin: 0 auto 10px; border: 5px dashed blue; background: gray; text-align: center; color: #fff; } .dropzone.active { border-color: green; background: rgba(0, 0, 0, .3); } this div is draggable Drag something into here var target = document.querySelector('.target') var dropzone = document.querySelector('.dropzone') target.addEventListener('dragstart', function(event) { event.target.classList.add('active') console.log('dragstart') }) target.addEventListener('drag', function(event) { console.log('drag') }) target.addEventListener('dragend', function(event) { event.target.classList.remove('active') console.log('dragend') }) dropzone.addEventListener('dragenter', function(event) { event.target.classList.add('active') console.log('dragenter') }) dropzone.addEventListener('dragover', function(event) { event.preventDefault() console.log('dragover') }) dropzone.addEventListener('dragleave', function(event) { event.target.classList.remove('active') console.log('dragleave') }) dropzone.addEventListener('drop', function(event) { console.log('drop') if (target.classList.contains('active')) { dropzone.appendChild(target) } var files = event.dataTransfer.files if (files.length) { for (var i = 0; i < files.length; i++) { var p = document.createElement('p') p.innerHTML = files[i].name + ' ' + (files[i].size / 1024).toFixed(2) + 'KB' dropzone.appendChild(p) } } else { var data = event.dataTransfer.getData('text/plain') || event.dataTransfer.getData('text/uri-list') if (/^data:image/.test(data)) { var img = new Image() img.src = data dropzone.appendChild(img) } else if (data) { dropzone.innerText = data } } event.target.classList.remove('active') event.preventDefault() }, true) 实现代码如下： css12345678910111213141516171819202122232425/* 可被拖拽的 div */.target { width: 200px; margin: 0 auto 10px; background: #999; text-align: center;}.target.active { background: yellow; color: red;}/* 拖拽放置的容器 */.dropzone { width: 500px; min-height: 200px; margin: 0 auto; border: 5px dashed blue; background: gray; text-align: center; color: #fff;}.dropzone.active { border-color: green; background: rgba(0, 0, 0, .3);} html12&lt;div class=\"target\" draggable=\"true\"&gt; this div is draggable &lt;/div&gt;&lt;div class=\"dropzone\"&gt; Drag something into here &lt;div&gt; js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465var target = document.querySelector('.target') // 目标var dropzone = document.querySelector('.dropzone') // 放置区/* 可拖拽的目标事件 */// 拖拽目标开始时触发一次target.addEventListener('dragstart', function(event) { event.target.classList.add('active')})// 鼠标未松开拖拽目标，将持续触发该事件target.addEventListener('drag', function(event) { console.log('drag')})// 鼠标松开拖拽目标，触发一次target.addEventListener('dragend', function(event) { event.target.classList.remove('active')})/* 放置区事件 */// 目标进入放置区，触发一次dropzone.addEventListener('dragenter', function(event) { event.target.classList.add('active')})// 目标处于放置区，将持续触发该事件dropzone.addEventListener('dragover', function(event) { // 如果想要捕获 drop 事件 就一定得在该事件中阻止默认事件 event.preventDefault()})// 目标离开放置区，触发一次dropzone.addEventListener('dragleave', function(event) { event.target.classList.remove('active')})// 目标在放置区被释放，触发一次dropzone.addEventListener('drop', function(event) { // 拖拽的是 target DOM if (target.classList.contains('active')) { dropzone.appendChild(target) } // 拖拽的是文件 var files = event.dataTransfer.files if (files.length) { for (var i = 0; i &lt; files.length; i++) { var p = document.createElement('p') p.innerHTML = files[i].name + ' ' + (files[i].size / 1024).toFixed(2) + 'KB' dropzone.appendChild(p) } } else { // 拖入的是文本 var data = event.dataTransfer.getData('text/plain') || event.dataTransfer.getData('text/uri-list') if (/^data:image/.test(data)) { var img = new Image() img.src = data dropzone.appendChild(img) } else if (data) { dropzone.innerText = data } } event.target.classList.remove('active') // 阻止默认动作（如打开一些元素的链接） event.preventDefault()}, true) 提示 拖拽事件是支持冒泡的，可以在 document 上监听上述事件。注意：drop 事件在 dragend 之前触发！！在 dragover 中阻止默认事件，才能监听到 drop 事件！！！ 上述例子在 dropzone 上监听的 dragleave 事件，如果 dropzone 含有子 DOM ，从父 DOM (dropzone) 拖拽到子 DOM 也会触发 dragleave 事件！！这点和 mouserleave 事件不同。 而 dropzone 上的 dragover 事件不受 dropzone 的子 DOM 的影响，依然持续触发！！！这点和 mouseover 事件不同，mouseover 事件在鼠标进入目标元素时触发一次，进入和离开目标元素的子元素（或子子元素）都会触发一次。 FileReaderFileReader 对象允许 Web 应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。 其中 File 对象可以是来自用户在一个 &lt;input&gt; 元素上选择文件后返回的 FileList 对象,也可以来自拖放操作生成的 DataTransfer 对象,还可以是来自在一个 HTMLCanvasElement 上执行 mozGetAsFile() 方法后返回结果。 属性FileReader 的实例有以下几个只读属性 属性 描述 error 一个 DOMException，表示在读取文件时发生的错误 。 readyState 表示 FileReader 状态的数字。(0 还没有加载任何数据; 1 数据正在被加载; 2 已完成全部的读取请求) result 文件的内容。该属性仅在读取操作完成后才有效，数据的格式取决于使用哪个方法来启动读取操作。 方法FileReader 的实例有以下几个实例方法 方法 描述 abort() 中止读取操作。在返回时，readyState 属性为 DONE。 readAsArrayBuffer(blob) 开始读取指定的 Blob 中的内容, 一旦完成, result 属性中保存的将是被读取文件的 ArrayBuffer 数据对象. readAsBinaryString(blob) 开始读取指定的 Blob 中的内容。一旦完成，result 属性中将包含所读取文件的原始二进制数据。该特性是非标准! readAsDataURL(blob) 开始读取指定的 Blob 中的内容。一旦完成，result 属性中将包含一个 data: URL 格式的字符串以表示所读取文件的内容。 readAsText(blob[,edncoding]) 开始读取指定的 Blob 中的内容。一旦完成，result 属性中将包含一个字符串以表示所读取的文件内容 edncoding 默认 utf-8 一个实例不能连续读取多个文件？？求解🙏 事件FileReader 的实例有以下几个事件，因为 FileReader 继承自EventTarget，所以所有这些事件也可以通过 addEventListener 方法使用。 事件 描述 onabort 处理 abort 事件。该事件在读取操作被中断时触发。 onerror 处理 error 事件。该事件在读取操作发生错误时触发。 onload 处理 load 事件。该事件在读取操作完成时触发。 onloadstart 处理 loadstart 事件。该事件在读取操作开始时触发。 onloadend 处理 loadend 事件。该事件在读取操作结束时（要么成功，要么失败）触发。 onprogress 处理 progress 事件。该事件在读取 Blob 时触发。 示例读取上传的图片、文本 .read-file-result { min-height: 200px; margin: 10px; border: 4px dotted blue; } 👉 👉 function empty() { document.querySelector('.read-file-result').innerHTML = '' } // 遍历选取的文件 function fileChange(target) { var ignoreFiles = [] for (var i = 0; i < target.files.length; i++) { var file = target.files[i] var isImage = /^image/i.test(file.type) var isText = /^text/i.test(file.type) !isImage && !isText ? ignoreFiles.push(file.name) : readFile(file, isText) } ignoreFiles.length && confirm('已忽略如下文件:\\r\\n' + ignoreFiles.join('\\r\\n')) ignoreFiles = [] } // 开始读取文件 function readFile(file, isText) { var fileReader = new FileReader() fileReader.onload = function() { insertDOM(this.result, isText, document.querySelector('.read-file-result')) } fileReader.onprogress = function(event) { console.log('文件读取进度：' + event.loaded + '/' + event.total) } isText ? fileReader.readAsText(file, 'utf-8') : fileReader.readAsDataURL(file) } // 显示读取结果 function insertDOM (result, isText, container) { var dom = null if (isText) { dom = document.createElement('p') dom.innerText = result } else { dom = new Image() dom.src = result } container.appendChild(dom) } 实现代码如下： css12345.read-file-result { min-height: 200px; margin: 10px; border: 4px dotted blue;} html12👉&lt;input type=\"file\" multiple onchange=\"fileChange(this)\"&gt;&lt;div class=\"read-file-result\"&gt;&lt;/div&gt; js123456789101112131415161718192021222324252627282930313233343536373839// 遍历选取的文件function fileChange(target) { var ignoreFiles = [] for (var i = 0; i &lt; target.files.length; i++) { var file = target.files[i] var isImage = /^image/i.test(file.type) var isText = /^text/i.test(file.type) !isImage &amp;&amp; !isText ? ignoreFiles.push(file.name) : readFile(file, isText) } ignoreFiles.length &amp;&amp; confirm('已忽略如下文件:\\r\\n' + ignoreFiles.join('\\r\\n')) ignoreFiles = []}// 开始读取文件function readFile(file, isText) { var fileReader = new FileReader() // 一个实例不能连续读取多个文件？？ fileReader.onload = function() { insertDOM(this.result, isText, document.querySelector('.read-file-result')) } fileReader.onprogress = function(event) { console.log('文件读取进度：' + event.loaded + '/' + event.total) } isText ? fileReader.readAsText(file, 'utf-8') : fileReader.readAsDataURL(file)}// 显示读取结果function insertDOM (result, isText, container) { var dom = null if (isText) { dom = document.createElement('p') dom.innerText = result } else { dom = new Image() dom.src = result } container.appendChild(dom)} — The End —","link":"/js/2017/02/20/"},{"title":"ES5 严格模式中的报错","text":"ES5 引入了 严格模式 （strict mode）的概念。严格模式是为 JavaScript 定义了一种不同的解析与执行模型，ES3 中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。这是为未来的语法过渡，也使得 js 执行效率提高 开启的方式： 对某个脚本使用：在脚本第一行书写 ‘use strict’ 对某个函数使用：在函数体内部第一行 书写 ‘use strict’ 不用 var 申明变量12'use strict'a = 1 // Uncaught ReferenceError: a is not defined 对只读属性赋值123'use strict'var str = 'hello'str.length = 1 // Uncaught TypeError: Cannot assign to read only property 'length' of string 'hello' 对没有存值器（setter）的属性赋值12345'use strict'var o = { get a() { return 1 }}o.a = 2 // Uncaught TypeError: Cannot set property a of #&lt;Object&gt; which has only a getter 对禁止扩展的对象添加属性1234'use strict'var o = { a: 0 }Object.preventExtensions(o)o.b = 1 // Uncaught TypeError: Cannot add property b, object is not extensible eval arguments 用作标识名12345'use strict'var eval = 17var arguments = 17 // Unexpected eval or arguments in strict modefunction fn(eval) {} // Uncaught SyntaxError: Unexpected eval or arguments in strict mode 函数有重名的参数1234function f(a, a, b) { 'use strict' return a + b} // Uncaught SyntaxError: Duplicate parameter name not allowed in this context 前缀 0 表示八进制的数字12'use strict'var n = 0100 // Uncaught SyntaxError: Octal literals are not allowed in strict mode. this 默认指向 undefined12345'use strict'var a = 1(function () { return this.a})() // Uncaught TypeError: 1 is not a function 使用 1234567891011'use strict'function fn() { fn.caller fn.arguments // or arguments.caller arguments.callee}fn() // Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be// accessed on strict mode functions or the arguments objects for calls to them at fn 删除变量123'use strict'var a = 1delete a // Uncaught SyntaxError: Delete of an unqualified identifier in strict mode. 使用 with 语句123456'use strict'var a = 1var o = { a: 2 }with (o) { a = 3} // Uncaught SyntaxError: Strict mode code may not include a with statement 保留字做变量名保留字有 implements interface let package private protected public static yield 等12'use strict'var implements // Uncaught SyntaxError: Unexpected strict mode reserved word — The End —","link":"/js/2017/08/26/"},{"title":"列举 Js 中常见的错误类型🐛","text":"JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供 Error 构造函数，所有抛出的错误都是这个构造函数的实例。我们可以访问实例的 message 属性来获取其中携带的提示消息，大多数 JavaScript 引擎还提供 name（错误名称） 和 stack（错误的堆栈） 属性。 Error 实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6 个派生错误对象。分别是 语法错误、引用错误、类型错误、执行错误、URI解析错误、超出范围错误。以下按开发中出现的概率，例举 Js 中出现的这几种常见错误。 🐞语法错误 SyntaxError这类错误都是在语法解析阶段就可以发现，大多数情况是由于我们书写错误导致的，如下几个常见的语法错误提示: 变量名不合法12var 0boj = {} // Uncaught SyntaxError: Invalid or unexpected tokenvar null = '' // Unexpected token null 变量值不合法12var str = \"hello\"\" // Uncaught SyntaxError: Invalid or unexpected tokenvar arr = ] // Uncaught SyntaxError: Unexpected token ] JSON 解析123456JSON.parse('{ key: \"world\" }') // Uncaught SyntaxError: Unexpected token k in JSON at position 2try { throw new SyntaxError('Don\\'t parse error instance with JSON')} catch(err) { JSON.parse(err) // Uncaught SyntaxError: Unexpected token S in JSON at position 0} 这类错误提示有个特点，就是 Unexpected token 非预期的词法单元。很多人写 js 语句末尾会省略分号，在代码压缩的过程中会把回车换行符去掉，从而可能导致语法 js 解析错误 注意undefined 是个特列，在不同运行环境的表现不一！ undefined 不是保留字！用 var 声明 undefined 作为变量不会报错，但 undefined 还是那个 undefined12var undefined = 2016 // 2016console.log(undefined) // undefined 但是在 IE6、7、8 里面，undefined 是可以被赋值，所以 Jquery 时代很多库都是执行的时候传入 undefined 来保证内部的 undefined 没有被赋值的12345var undefined = 'hello'(function lib(window) { // do somethings ... console.log(undefined) // undefined})(window, undefined) 在严格模式下用会 js 引擎认为 undefined 是 window 下的只读属性，虽然可以用 var 声明 undefined 作为变量，但给 undefined 赋值会报错123'use strict'var undefinedundefined = 2016 // Uncaught TypeError: Cannot assign to read only property 'undefined' of object '#&lt;Window&gt;' 用 let、const 声明 undefined 作为变量会报错12let undefined // Uncaught SyntaxError: Identifier 'undefined' has already been declared const undefined // Uncaught SyntaxError: Missing initializer in const declaration 🐞引用错误 ReferenceError当 js 代码中引用了未定义的变量时，或者是等式左边不可被赋值时，会报引用错误 变量未定义12console.log(a) // Uncaught ReferenceError: a is not defineda() // Uncaught ReferenceError: a is not defined 赋值操作12345678910this = 'hello world' // Uncaught ReferenceError: Invalid left-hand side in assignment// 少写一个等号var a = 2016if (2020 = a) { /** do somethings ... **/ }// Uncaught ReferenceError: Invalid left-hand side in assignmentfunction fn () { return 2020 }if (fn() = a) { /** do somethings .. **/ }// Uncaught ReferenceError: Invalid left-hand side in assignment 这类错误有个特点，要么报某变量未定义(is undefined)，要么报无法给等式左边赋值 🐞类型错误 TypeError这类错误产生的原因是，变量或参数不是预期类型时发生的错误 赋值操作1234567// Object.assign 给 null 分配值Object.assign(null, { key: 'hello' }) // Uncaught TypeError: Cannot convert undefined or null to objectconst { a, b } = null // Uncaught TypeError: Cannot destructure property `a` of 'undefined' or 'null'.// 严格模式下一些赋值操作'use strict'window = null // Uncaught TypeError: Cannot assign to read only property 'window' of object '#&lt;Window&gt;'var undefined = 2016 // Uncaught TypeError: Cannot assign to read only property 'undefined' of object '#&lt;Window&gt;' new 操作12new window // Uncaught TypeError: window is not a constructornew 'hello' // Uncaught TypeError: hello is not a constructor 执行函数123456789101112var nameSpace = { fn () {}}nameSpace.fN()// Uncaught TypeError: nameSpace.fN is not a function// 后端返回数据不规范时采坑 😫fetch('/api/detail').then(res =&gt; { res.array.forEach(/** do somethings ... **/) console.log(res) // { array: null } or { }})// Uncaught TypeError: Cannot read property 'forEach' of null or undefined in 操作123456var o = undefinedif ('key' in o) { /* do somethings */ }// Uncaught TypeError: Cannot use 'in' operator to search for 'key' in undefinedvar o = nullif ('key' in o) { /* do somethings */ }// Uncaught TypeError: Cannot use 'in' operator to search for 'key' in null 🐞URI解析错误 URIError对字符进行 URI 编码、解码的时候出现错误的，目前我只遇到解码时报错 解码 url12decodeURI('%3%4%5') // Uncaught URIError: URI malformeddecodeURIComponent('%3%4%5') // Uncaught URIError: URI malformed 🐞超出范围错误 RangeError当对象的值超出有效范围的时候，会抛出 RangeError 错误 数组长度123456// 指定 length 是负数var rect = []rect.length = -1 // Uncaught RangeError: Invalid array length// 创建一个含有 2^32 项 undefined 的数组(数组最大长度为 2^32 -1)new Array(2**32) // Uncaught RangeError: Invalid array length 123456789// 递归调用时function fn() { /* do somethings ... */ fn()}while(true) { fn()}// Uncaught RangeError: Maximum call stack size exceeded js 的最大调用栈受宿主环境影响，从几千到几万不等。像我的 edge(v17.17134) 3000+，我的 chrome(v67.0.3396.99) 12000+，我的 node(v8.11.3) 12000+，以下函数可以获得当前环境的最大调用栈12345678(function getMaxCallStackSize() { try { return 1 + getMaxCallStackSize() } catch (e) { // Call stack overflow return 1 }})() 🐞执行错误 EvalErroreval 函数没有被正确执行，该错误类型已经不再使用了，执行错误时抛出上述几种错误 123456var o = { a: 2018 }var oStr = JSON.stringify(o) // \"{\"a\":4}\"// 正确执行⬇eval(\"(\" + oStr + \")\") // {a: 2018}// 语法错误⬇eval(oStr) // Uncaught SyntaxError: Unexpected token : — The End —","link":"/js/2017/08/19/"},{"title":"jQuery —— Write Less，Do More","text":"2006年1月 John Resig 等人创建了 jQuery。 015年，jQuery 被用于前100万个网站中的63％（根据BuiltWith），以及所有互联网网站的17％。[15]截至 2018年6月，jQuery被用于前 100 万个网站中的 73％，并且占所有网站的 22.4％（根据BuiltWith）。jQuery 风靡一时。 特点 书写简洁、代码优雅，链式操作，.end() 回溯 强大的选择器，支持 CSS1-3 所有的选择器 浏览器兼容性好，兼容 IE6、7、8 统一的入口，降低了学习、记忆成本 强大的动画效果、事件支持 开源、免费 插件丰富，可扩展性强 入口函数入口函数一123$(document).ready(function(){// ...}) 入口函数二123$(function(){ // ...}) $()的几种常用用法 $(‘#id’) 选择某个元素，返回值为 jQuery 对象 $(DOM) 将 DOM 对象转换成 jQuery 对象 $(‘&lt;div&gt;&lt;/div&gt;’) 创建元素，返回值为 jQuery 对象 $(function(){ }) 入口函数的简写方式 $(‘div’).html() 获取内容的时候，只返回匹配到的第一个元素的数据 data() 跟 .attr() 方法的区别: 获取数据的时候，attr() 方法需要传入参数，data() 方法可以不传入参数，这时候获取到的是一个 js 对象，即使没有任何 data 属性。 获取到的数据类型不同，attr 方法获取到的数据类型是字符串 (String)，data 方法获取到的是相应的类型。 data 方法获取到数据之后，我们使用一个对象来接收它，那么就可以直接操作(设置值或获取值)这个对象，而 attr 方法不可以。 并且通过这种方式，要比 .data(key, value) 的方式更高效！ data-attribute 属性会在页面初始化的时候放到 jQuery 对象，被缓存起来，而 attr 方法不会。 选择器 选择器 使用方法 基本选择器 #id, .class, element, * 层级选择器 空格, &gt;, +, ~, , 基本过滤选择器 :first, :last, :eq(index), :lt(index), :gt(index), :odd, :even 筛选选择器 .eq(index), .children(), .parent(), .siblings(), .find() 属性选择器 E[href], E[href='qq'], E[href!='baidu'], E[href^='web'], E[href$='cn'], E[href*='i'], E[href][title='world'] 过滤方法 .first(), .last(), .eq(index), .not('.active') 动画show()hide()fadeIn()fadeOut()fadeTo()slideDown()slideUp()slideToggle ()animate()1$('div').animate({ height: '300px', opacity: '0.4' },'slow'); DOM 操作css()addClass()removeClass()toggleClass()attr()removeAttr()val()html()text()append()prePend()DOM 对象跟 jQuery 对象相互转换jQuery 对象转 DOM 12$('btn').get(0)$('btn')[0] 绑定事件bind123$('btn').bind('“click”', function() { // ...} ) one123$('btn').one('click', function() { // ...}) delegate123$('btn').delegate('p', 'click', function() { // ...}) on最现代的方式，兼容zepto，1.7以后的 jQuery 版本被 on 取代 123$('ul').on('click', 'li', function() { // ...}) 解绑事件unbindundelegateoff触发事件clicktrigger触发事件，并且触发浏览器默认行为 triggerHandler不触发浏览器默认行为 ajax12345678$.ajax({ url: 'xxx/ss/df', type: 'POST', dataType: 'json', data: { username: 'shinekidd', id: 78 }, success: function(data) { }, error: function(e) { }}) 全局设置 1234567891011121314151617181920$.ajaxSetup({ global: true, cache: false, timeout: 2000, dataType: 'json', error: function (xhr, status, err) { console.log('ajax status: ', status); console.error('ajax error: ', err) var msg = ''; switch (xhr.status) { case 0: // ... } msg &amp;&amp; CreatePop.error(msg); }, success: function (result, status, xhr) { // console.log('ajax status: ', status); result.error * 1 &amp;&amp; result.msg &amp;&amp; CreatePop.warning(result.msg); }}) 特点data() 与 attr()获取数据的时候，attr 方法需要传入参数，data 方法可以不传入参数，这时候获取到的是一个 js 对象，即使没有任何 data 属性。获取到的数据类型不同，attr 方法获取到的数据类型是字符串 (String)，data 方法获取到的是相应的类型。data 方法获取到数据之后，我们使用一个对象来接收它，那么就可以直接操作(设置值或获取值)这个对象，而 attr 方法不可以。 并且通过这种方式，要比.data(key,value) 的方式更高效！ data-attribute 属性会在页面初始化的时候放到 jQuery 对象，被缓存起来，而 attr 方法不会。html 里面的 data 属性，例如：data-ROLE，jQuery 获取的时候用：$(‘div’).data(‘role’);当使用 jQuery 设置 data 属性的时候，例如：$(‘div’).data(‘UPCASE’,123); ，那么获取的时候，要使用：$(‘div’).data(‘UPCASE’);&lt;div data-role=”page” data-last-value=”43” data-hidden=”true” data-options=’{“name”:”John”}’&gt;注意HTML属性不区分大小写&lt;/div&gt;$( ‘div’ ).data( ‘lastValue’ ) === 43;lastValue -&gt; data-last-value mouseover 与 mouseentermouseover/mouseout 事件，鼠标经过的时候会触发多次，每遇到一个子元素就会触发一次。mouseenter/mouseleave 事件，鼠标经过的时候只会触发一次 隐式迭代默认情况下，会自动迭代执行jQuery选择出来所有dom元素的操作如果获取的是多元素的值，默认返回的是第一个元素的值。 $.each、$.map、$.trim123456789101112131415// 参数顺序是一致的$node.each(function(index,element){ })$.each([1,2,3,5,6,7], function (i,v) { console.log(i + ' : ' + v)})// map返回数组$(“li”).map(function(index, element){ return $(this).text()});// 与上面的参数是相反的$.map(array, function(object, index) { return object * index }) 解决 $ 冲突执行如下代码，释放 $ 1$.noConflict() 可以使用其他库的 $ 符号了 $ 对象扩展方法例如扩展 lxCfbg 方法到 $ 上 1234567891011121314151617function ($) { $.fn.lxCfbg = function (options) { // 合并参数 var opts = $.extend({ \"color\": \"#000\", \"font-size\": \"16px\", \"background-color\": \"#fff\" }, options) // $this.css({ \"color\": opts.color, \"font-size\": opts[\"font-size\"], \"background-color\": opts[\"background-color\"] }) return $this }})(jQuery) — The End —","link":"/js/2017/01/01/"},{"title":"Ajax 中常见的错误🐛","text":"Ajax 作为 Web 开发中重要的通讯技术，悉知使用中常见的错误有利我们规快速发现问题，解决问题，避错误。XMLHttpRequest，$.ajax ，axios 总结在开发中经常遇到的问题如下： 请求的 URL 不合法在发送 ajax 请求的时候，由于传入的 url 不合法，在调用 open 方法的时候报错，或在掉用 send 方法时请求失败报错 在原生 XMLHttpRequest 中123456789101112131415161718// commonvar app_name = undefinedvar host = '//192.168.1.31'var port = 8080var api = host + ':' + port + app_name + '/list' // //192.168.1.31:8080undefined/listvar method = 'GET'var xhr = new XMLHttpRequest()// 1.存在端口号，在调用 open 方法时报错xhr.open(method, api, true) // Uncaught DOMException: Failed to execute 'open' on 'XMLHttpRequest': Invalid URL// 2.不存在端口号，在调用 sennd 方法时报错var api = host + app_name + '/list' // //192.168.1.31undefined/listxhr.open(method, api, true) xhr.send(null)// GET http://192.168.1.31undefined/list 502 (Bad Gateway) 也可能无响应// 如果跨域，还会报跨域的错误 在原生 Fetch 中12345678910111213var app_name = undefinedvar host = '//192.168.1.31'var port = 8080var api = host + ':' + port + app_name + '/list' // //192.168.1.31:8080undefined/list// 1.存在端口号时报错fetch(api)// Uncaught (in promise) TypeError: Failed to execute 'fetch' on 'Window': Failed to parse URL from //192.168.1.31:8080undefined/list// 2.不存在端口号时请求无响应报错var api = host + app_name + '/list' // //192.168.1.31undefined/listfetch(api)// Uncaught (in promise) TypeError: Failed to fetch /... 第三方库 axios 中报错123456789// 在二次封装 axios 时，由于主机地址带有端口，并且没有以 '/' 结尾，又导致 baseURL 拼接错误，最终导致 URL 不合法let app_name = undefinedlet host = '//192.168.1.31:8080'let _axios = axios.create({ baseURL: host + app_name // //192.168.1.31:8080undefined});_axios.get('/list').then(res =&gt; { /* do somethings ... */ })// Uncaught (in promise) DOMException: Failed to execute 'open' on 'XMLHttpRequest': Invalid URL — The End —","link":"/js/2017/09/02/"},{"title":"常用的开源库免费 CDN 服务器","text":"使用 CDN (Content Delivery Network) 可以有效地加速静态资源的载入速度，提高网站的访问体验，开源的力量，使得开源库能使用免费的 CDN 服务，收集几个常用的开源库 CDN 服务器地址 cdnjs @USAby CloudFlare.Everyone loves the Google CDN right? Even Microsoft runs their own CDN.The problem is, they only host the most popular libraries.We host it all - JavaScript, CSS, SWF, images, etc! jsdelivr @USAby MaxCDN.jsDelivr is a free CDN (Content Delivery Network) where any web developer can host their files, including CSS, fonts, JavaScript, jQuery plugins, etc. unpkg @USAunpkg is a fast, global content delivery network for everything on npm. Use it to quickly and easily load any file from any package using a URL like: bootcdnBootCDN 是 Bootstrap 中文网支持并维护的前端开源项目免费 CDN 服务，致力于为 Bootstrap、jQuery、Angular、Vuejs 一样优秀的前端开源项目提供稳定、快速的免费 CDN 加速服务。BootCDN 所收录的开源项目主要同步于 cdnjs 仓库。 staticfile七牛云存储提供支持。我们的目标是提供这样一个仓库，让它尽可能全面收录优秀的开源库，并免费为之提供 CDN 加速服务，使之有更好的访问速度和稳定的环境。同时，我们也提供开源库源接入的入口，让所有人都可以提交开源库，包括 JS、CSS、image 和 swf 等静态文件。此仓库由 Sofish、hfcorriez 和 ikbear 更新和维护。由国内优秀的云存储服务商 七牛云存储 提供存储和加速。国外源同步于 CDNJS。 baomitu360 前端静态资源库是由奇舞团支持并维护的开源项目免费 CDN 服务，支持 HTTPS 和 HTTP/2，囊括上千个前端资源库和 Google 字体库。本站静态资源库数据均同步于 cdnjs，如发现版本更新不及时或未收录，欢迎向 cdnjs 提交 PR。 线上项目慎用开源库 CDN。一方面这类 CDN 有时存在不稳定的情况（我遇到了 2 次了），另一方是面出于安全性的考量，毕竟引入别人的 js 链接。 — The End —","link":"/js/2017/05/06/"},{"title":"百度 echarts 基本使用","text":"做数据分析，少不了用到 canvas 绘图，echarts 和 chart 和D3 在绘图上的有非常好的表现。百度出品的 echarts，文档清晰，demo 可实时编辑预览，支持个性定制，webpack 按需引入。对首次接触或者英文不太好的开发者非常友好。如果你的业务要兼容 IE6，那么 ehcarts2 可能是你的不二选择。 以下记录自己入门 echarts 的一些经验 引入方式script 标签引入。除非你要使用所有的 echarts 功能，否则建议根据自己的需求定制，或使用 加速，因为即使是 echarts.min.js 的体积也还是太大了。1&lt;script src=\"echarts.min.js\"&gt;&lt;/script&gt; 使用 webpack 按需引入模块，使打包的体积可控。支持的模块见列表1234567// 主模块必选import echarts from 'echarts/lib/echarts'// 以下模块可选import line from 'echarts/lib/chart/line' // 折线图import bar from 'echarts/lib/chart/bar' // 柱状图import tooltip from 'echarts/lib/component/tooltip' // 提示工具import title from 'echarts/lib/component/title' // 图表标题工具 部分配置参数解释以一个 dom 节点作为容器，绘制 echarts，用框架开发时，要在 dom 挂载后的钩子中初始化 echarts 实例vuejs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114export default { data() { return {} }, mounted() { this.$api.getCharts(res =&gt; { var xAxisData = generateXAxis(res.x) var yAxisData = generateYAxis(res.y) this._init({ xAxisData, yAxisData }) } // 旋转屏幕的时候，重绘图表 window.addEventListener('orientationchange', this._resetChart) }, methods: { // 传入 option 初始化 echarts _init(extOpt) { this.chartInstance = echarts.init(this.$refs.lineYear) this.chartInstance.setOption(this._opt(extOpt)) }, // 图表配置 _opt(extOpt) { return { title: 'xxx 统计图', // 一般不使用 echarts 默认的标题样式，而是根据 UI 用 CSS 自行实现 color: ['#00b4f7'], // 可设置多个颜色，series 配置里的默认色依次从中获取 tooltip: { // 点击图标显示提示框，可格式化显示内容 trigger: 'axis', // 触发方式，可选 'item' }, grid: { height: 120, left: 8, right: 8, top: 40 }, // 可以是数组，在一个 canvas 上绘制多个 chart，可调整偏移量来改变绘制的边界 xAxis: { name: '(日期)', // 坐标轴名称。 nameTextStyle: { // 定义坐标轴名称字体的样式，设置字体色和背景色一样，再通过文字阴影、阴影偏移，可以实现自定义文字的位置 color: '#fff', fontSize: 10, textShadowColor: '#999', textShadowOffsetX: -45, textShadowOffsetY: 25 }, type: 'category', // 坐标轴类型。可以是 'value' 数值轴，'time' 时间轴，'log' 对数轴。 boundaryGap: true, // 坐标轴两边是否留白，折线图可能有需求从 x 轴原点开始（不留白），而柱状图要和 y 轴有一定间隔（留白） interval: '', // 刻度间隔 无法在类目轴中使用。在时间轴（type: 'time'）中需要传时间戳，在对数轴（type: 'log'）中需要传指数值 axisTick: { show: false, // 显示坐标的刻度 alignWithLabel: true, // 在 boundaryGap 为 true 的时候有效，可以保证刻度线和标签对齐 }, axisLabel: { // 定义刻度标签文字的一些样式，可格式化 interval: 0, // 刻度标签的显示间隔，在类目轴中有效。移动端屏幕窄，有些刻度标签不显示，设置为 0 强制显示所有标签 color: '#777', fontSize: 13 }, axisLine: { lineStyle: { color: '#ccc', type: 'dashed' } // 改变 x 轴颜色，线形 }, splitLine: { show: true, // 显示垂直 x 轴的分割线 lineStyle: { // 分割线样式 type: 'dashsed', color: '#e7ecf1' } }, data: extOpt.xAxisData // x 轴数据 }, yAxis: { // 和 x 轴的设置大同小异 show: false, // 显示轴线 min: 0, // 坐标轴刻度最小值 max: 100, // 坐标轴刻度最大值 }, series: [ { type:'line', // 图表类型 name: '发送量', // 顶部的图注名称 smooth: true, // 折线图变成曲线，转折点平滑过渡 symbolSize: 7, // 折点标记的大小，设置为 0 则不显示 symbol: 'circle', // 折点样式，如小圆圈，三角形，箭头之类的 lineStyle: { // 折线样式 normal: { width: 1 } shadowColor: 'rgba(116, 202, 225, 0.6)', shadowBlur: 4 shadowOffsetY: -3, }, itemStyle: { color: { // 设置折线在水平方向的渐变色 type: 'linear', x: 0, y: 0, x2: 1, y2: 0, colorStops: [{ offset: 0, color: '#74cdff' // 0% 处的颜色 }, { offset: 1, color: '#7677ff' // 100% 处的颜色 }] } }, label: { // 显示数据的标签（比如数值），可自定义样式 show: true, position: 'top', color: '#444', fontSize: 14 }, data: extOpt.yAxisData // y 轴数据 }, { type: 'bar', barWidth: 1, // 设置成 1 则柱状图是一根线 data: extOpt.yAxisData // y 轴数据 } ] }, _resetChart () { this.chartInstance.resize() } }, beforeDestroy () { window.removeEventListener('orientationchange', this._resetChart) } }, 更多详细配置，见官方配置项手册，手册的目录结构和配置项一一对应，非常便于查阅！ — The End —","link":"/js/2017/04/29/"},{"title":"sheetjs 库的基本使用","text":"前端常常有批量录入的需求，一般我们都采用 excel 来导入数据。SheetJS js-xlsx 是一款优秀的处理电子表格类的库。支持浏览器和 nodejs sheet_to_XLSX.utils 提供了 sheet_to_json() sheet_to_csv() sheet_to_txt() sheet_to_html() sheet_to_formulae() 等方法，读取工作簿(workbook)的 sheet ，并返回数据 我们常用的是 XLSX.utils.sheet_to_json() 、XLSX.utils.sheet_to_html() 方法 XLSX.utils.sheet_to_json()下面是读取 excel 文件返回 js 对象的小 demo excel 内容如图： 读取结果如下： 1234567891011121314[ { name: \"灯泡\", model: \"飞利浦\", price: 1588, count: 5 }, { name: \"桌子\", model: \"铜奖\", price: 200, count: 45 }] 实现代码如下： 123&lt;form name=\"upload\"&gt; &lt;input type=\"file\" accept=\".xlsx, .xls\" onchange=\"handleFile(event)\"&gt;&lt;/form&gt; 1234567891011121314function handleFile (e) { var reader = new FileReader() var file = e.target.files[0] reader.readAsArrayBuffer(file) reader.onload = function () { // 要指定读取文件源的类型，返回整个工作簿，含有多个 sheet var workbook = XLSX.read(reader.result, { type: 'array' }) // 取第一个 sheet var worksheet = workbook.Sheets[workbook.SheetNames[0]] // header 指定头部每一列的字段，range 忽略第一行（表头），返回 js 对象 var sheetObj = XLSX.utils.sheet_to_json(worksheet, { header: ['name', 'model', 'price', 'count'], range: 1 }) console.log(sheetObj) }} 提示 使用 readAsArrayBuffer() 方法读取文件，XLSX.read() 的参数 type 可以是 array 或 buffer 可以使用 readAsBinaryString() 方法读取文件，但注意它是非标准属性，同时 XLSX.read() 的参数 type 应设为 binary XLSX.utils.sheet_to_html()下面是读取 excel 文件返回 html 字符串的 demo 默认输出的 htmlStr 是被 html body 包裹的没有 id 的 table 元素 部分代码同上已省略 1234// ...var htmlStr = XLSX.utils.sheet_to_html(worksheet, { id: 'output_excel', header: '' , footer: '' })console.log(htmlStr)// &lt;table id=\"output_excel\"&gt; .... &lt;/table&gt; _to_sheetXLSX.utils 提供了 json_to_sheet() 、aoa_to_sheet() 、table_to_sheet() 方法，输入 JavaScript 对象(object)、二维数组(array of array)、table 元素，导出excel 文件 以输入 JavaScript 对象，导出 excel 文件的 demo 为例，二维数组和 table 元素导出 excel 只是生成 worksheet 的方法不同 XLSX.utils.json_to_sheet()输入 JavaScript 对象 12345678910111213141516171819202122232425262728293031323334// 表头var sheetHeader = { name: '名称', model: '型号', price: '价格', count: '数量' }// 表格数据var sheetData = [ { name: '灯泡', model: '飞利浦', price: 1588, count: 5 }, { name: '桌子', model: '铜奖', price: 200, count: 45 }]// SheetJS 导出 excelexportExcel(sheetData, sheetHeader) function exportExcel(sheetData, sheetHeader, filename = 'export.xlsx', sheetName = 'sheet1') { sheetData.unshift(sheetHeader) // 创建一个工作簿 var worksbook = XLSX.utils.book_new() // 生成工作簿的一个 sheet ，忽略表头 var worksheet = XLSX.utils.json_to_sheet(sheetData, { header: Object.keys(sheetHeader), skipHeader: true }) // 添加 sheet 到工作簿 XLSX.utils.book_append_sheet(worksbook, worksheet, sheetName) // 写入数据到工作簿，返回 array buffer var arrayBuffer = XLSX.write(worksbook, { bookType: filename.split('.').pop(), bookSST: false, type: 'array' }) // 保存为 excel 文件 saveBlob(new Blob([arrayBuffer]), filename)}// 保存 blob 文件function saveBlob(blob, filename) { var anchor = document.createElement('a') anchor.download = filename anchor.href = URL.createObjectURL(blob) anchor.click() setTimeout(function() { URL.revokeObjectURL(anchor.href) }, 5000)} 调用 XLSX.write() 方法时使用参数 array 是为了直接返回的数据是 ArrayBuffer 。应为如果不是 ArrayBuffer ，new Blob() 的方式保存 excel 会失败，暂时不知到原因。看到有些做法是使用参数 ‘binary’ 再手动转成 ArrayBuffer 的，不知的出于什么目的。。。 XLSX.utils.aoa_to_sheet()输入二维数组 部分代码同上已省略 12345678// ...var aoa = [ ['名称', '型号', '价格', '数量'], // 表头 ['灯泡', '利浦', 1588, 5], ['桌子', '铜奖', 200, 45]]var worksheet = XLSX.utils.aoa_to_sheet(aoa)// ... XLSX.utils.table_to_sheet()输入 table 元素 部分代码同上已省略 1234// ...var tableEl = document.querySelector('table')var worksheet = XLSX.utils.table_to_sheet(tableEl)// ... sheet_addXLSX.utils 还提供了 sheet_add_aoa() sheet_add_json() 方法，可以在生成的 worksheet 的基础上增加数据 XLSX.utils.sheet_add_json()12345var data = [ { name: '凳子', model: '长木', count: 180, price: 5 }, { name: '扫把', model: '宝洁', count: 45, price: 25 }]XLSX.utils.sheet_add_json(worksheet, data, { skipHeader: true, origin: 'A4' }) XLSX.utils.sheet_add_aoa()12var data = [['凳子', '长木', 180, 5], ['扫把', '宝洁', 45, 25]]XLSX.utils.sheet_add_aoa(worksheet, data, { origin: 'A4' }) origin 参数表示数据在 worksheet 中插入的位置 参数 描述 'A4' 表格 sheet 中具体的坐标 { r: 4 c: 1 } 第 4 行(row)第 1 列(column)。同 ‘A4’ -1 在原有数据尾部追加数据。 — The End —","link":"/js/2017/05/13/"},{"title":"在 Vue 中使用 i18n 做国际化","text":"产品要走向国际，先把语言搞起来呀！Vue I18n 是 Vue.js 的国际化插件，非常好用！在此记录我的使用经验。 全局使用涉及的主要文件如下，语言文件放在 locale 文件加下 ├─src ├─main.js ├─locale ├─en.js ├─zh.js └─index.js 文件内容如下 ./src/locale/index.js123456789101112131415161718192021222324252627import Vue from 'vue'import VueI18n from 'vue-i18n'import en from './en'import zh from './zh'Vue.use(VueI18n)const LOCALE_KEY = 'locale_language'const DEFAULT_LANG = 'zh'const localeLang = window.localStorage.getItem(LOCALE_KEY) || DEFAULT_LANGconst i18n = new VueI18n({ locale: localeLang, fallbackLocale: DEFAULT_LANG, messages: { en, zh }})export { DEFAULT_LANG, localeLang}export default i18n ./src/locale/en.js12345678910export default { lang: 'English', frame: { header: { home: 'home page' ... } } ...} ./src/locale/zh.js12345678910export default { lang: '简体中文', frame: { header: { home: '主页' ... } } ...} ./src/main.js1234567import i18n from './locale'...new Vue({ i18n, ...}).$mount('#app') 只需要使用一个表单绑定 v-model=”$i18n.locale” 就能实现动态更换应用语言了。 单文件内使用上述的 en.js zh.js 都是全局先定义好的，在单个组件中可以在单独定义，优先级更高： 写在组件实例的 options 里 App.vue123456789101112export default { data () { ... }, i18n: { messages: { zh: { ... }, en: { ... } } } ...} 写在 &lt;i18n&gt; 标签里，这需要安装 vue-i18n-loader，并且内容必须是一个 JSON。你可以使用 yml 替代 JSON ，前提是要再配置一个 yaml-loader App.vue12345678910&lt;template&gt;...&lt;/template&gt;&lt;i18n&gt;{ \"zh\": { ... } \"en\": { ... }}&lt;/i18n&gt; 配置 vue-i18n-loader 依赖于 vue-loader ，vue-loader 版本 v15 以上的配置不一样，如下： vue-loader version &gt;= 15 1234567891011121314...rules: [ { test: /\\.vue$/, loader: 'vue-loader', }, { resourceQuery: /blockType=i18n/, type: 'javascript/auto', loader: '@kazupon/vue-i18n-loader' } ...]... vue-loader version &lt;= 14 12345678910111213141516171819...rules: [ { test: /\\.vue$/, loader: 'vue-loader', options: { preLoaders: { // 如果你在 &lt;i18n&gt; 内使用 yml 替代 JSON i18n: 'yaml-loader' }, loaders: { // you need to specify `i18n` loaders key with `vue-i18n-loader` (https://github.com/kazupon/vue-i18n-loader) i18n: '@kazupon/vue-i18n-loader' ... } } } ...]... 在单文件内同时使用上述两种方式时，只用第二种生效！ — The End —","link":"/js/2018/09/08/"},{"title":"ES6 的模块化","text":"历史上，JavaScript 一直没有自己的模块体系，直到 ES6 推出自己的模块化。它的实现不同于 CommonJS 和 AMD 的模块化，浏览器和服务器通用。但是目前浏览器和 nodejs 的支持有限。 下面简单记录 ES6 模块的特点 exportES6 使用关键字 export 输出模块 直接输出变量123export let bar = 'bar'export function foo () {}export class animal {} 输出一组变量123456const bar = 'bar'function boo () {}export { bar, foo} 默认输出1export default function foo() {} 上述函数名 foo 可写可不写，其实 export default 输出的是匿名函数，import 时可以自定义函数名。加载后是获取不到函数名 foo 的。 输出重命名123456const dinner = '晚餐吃什么？'const dessert = 'cake'export { dinner as supper, // 把 dinner 以变量名 supper 输出 dessert as sweetie} 错误的用法export 只能使用标识符 12345const foo = 'foo'export { bar: 'bar', foo: foo} export 不能写在块里面 1234if (true) { export function foo() {}}// Uncaught SyntaxError: Unexpected token export export default 的本质是把后面的值赋给 default 变量，所以后面不能接 let const var 语句 1234export default let bar = 'bar' // Uncaught SyntaxError: Unexpected token letexport default const foo = 'foo' // Uncaught SyntaxError: Unexpected token constexport default var baz = 'baz' // Uncaught SyntaxError: Unexpected token var// 一个文件里可以有多个 export 只能有一个 export default 12345export default class animal { constructor() {}}export default function foo () {}// Uncaught SyntaxError: Duplicate export of 'default' importES6 使用关键字 import 加载模块 加载指定12import { bar } from './moduleA.js'console.log(bar) 加载默认123import foo from './moduleA.js'// 等价于import { default as foo } from './moduleA.js' 加载全部12import * as moduleA from './moduleA.js'console.log(moduleA.bar) 加载重命名12// 把 supper 导入后保存在变量 dinner 里import { supper as dinner } from './moduleA.js' 同时加载12// foo 对应 export default 变量import foo, { bar } from './moduleA.js' 复合写法moduleB12import { bar, foo } from './moduleA.js'export { bar, foo } 如上需求可以复合写成如下 moduleB12345678// 导入导出指定export { bar, foo } from './moduleA.js'// 导出默认export { default } from './moduleA.js'// 整体导入导出，会忽略 export defaultexport * from './moduleA.js'// 导入导出重命名export { dinner as supper, default as dessert } from './moduleA.js' 错误的用法import 不能写在块里面 1234if (true) { import foo from './moduleA.js'}// Uncaught SyntaxError: Unexpected identifier import 不能使用表单式或变量 12const modulePath = './moduleA'import { bar } from modulePath // Uncaught SyntaxError: Unexpected identifier ES6 模块的特点静态加载CommonJS 和 AMD 模块，都是在代码运行时加载相应的模块。ES6 的模块编译时就完成了模块的加载，也叫静态加载。 严格模式与 ES5 使用 ‘use strict’ 开启严格模式不同，ES6 模块自动采用严格模式。 动态绑定通过 export 输出的模块内部变化时，同过 import 获取该模块可获得模块内部实时的值。与 CommonJS 对模块进行缓存不同 接口只读通过 import 加载的模块，不能重新赋值，类似 const 声明的变量一样。 import 命令提升import 命令有提升效果，应为它是编译的时就完成了模块加载。如下代码可正常执行 12foo()import foo from './moduleA.js' import() 函数由于 nodejs 的 require 加载模块是动态的，即在运行时加载模块。import 是静态加载，所以不能取代 require。因此有一个提案引入 import() 函数来实现动态加载模块。 import() 函数接受和 import 命令一样的参数，但该函数是异步加载，结果返回的是一个 Promise 对象。使用该函数很容易实现按需动态加载。 12345678const modulePath = './moduleA.js'if (true) { import(modulePath).then(({ bar }) =&gt; { console.log(bar) }).catch(e =&gt; { console.error(e) })} — The End —","link":"/js/2017/07/15/"},{"title":"js 的实现模块化的历程","text":"传统意义的网站只是提供浏览功能，随着网站功能越来越强大，如今的网站，已是“互联网应用程序”。而驱动这个应用程序的 JavaScript 也变得越来越庞大、复杂！开发、维护、管理这些 js 代码显得越来越困难了，实现 js 的模块化开发成为了迫切的需求。 以下简单记录 js 实现模块化的一些实现方式 函数单纯的把一个函数或多个函数放在一起，组成一个模块。这种方式污染了全局变量，管理起来也不清晰。 123456function bar { // do somethings}function foo { // do somethings} 对象把所有的模块成员塞进一个对象。这样减少了全局变量的污染，但这样会暴露所有模块成员，内部状态可以被外部改写。 12345678var module = { name: '_my_module', each: function () { // do somethings }}// 改写内部模块module.each = null 立即执行函数可以对上述方式进行改进，利用函数返回一个对象来创建。 12345678var module = (function () { return { name: '_my_module', each: function () { // do somethings } }})() 再改进一下，可以实现简单的模块扩展，模块依赖 12345678910111213141516var module = (function (mod) { return { name: '_my_module', each: function () { // do somethings }, // 该依赖依赖 moduleA getTime: function () { return mod.getTime() }, // 可扩展 extend: function (name, m) { this[name] = m } }})(window.moduleA || {}) CommonJSnodejs 推出后，js 可以用于复杂的服务器端编程，nodejs 参照了 CommonJS 规范实现了模块化。在 CommonJS 中，有一个全局变量 require 用于加载模块。 12var moduleA = require('moduleA')var time = moduleA.getTime() AMD正如上述，nodejs 是为服务端编程而实现了模块化，但浏览器端并没有实现。而 require 是同步加载的，在浏览器有网络传输延迟，使用同步加载模块显然不合理。为了保持模块使用风格的一致性，便探索出了异步模块定义（Asynchronous Module Definition），即 AMD 规范。实现了依赖模块异步加载，加载完后成通过回调执行。目前有两个主流库实现了 AMD 规范，分别是 require.js curl.js 1234require(['moduleA'], function(moduleA) { var time = moduleA.getTime() // ...}) 兼容性写法很多优秀的第三方库，使用兼容性写法，以兼容 CommonJS 、AMD 的模块化 1234567891011121314151617(function(global, factory) { // AMD 模块 if (typeof define === 'function' &amp;&amp; define.amd) { define([], factory) // CommonJS 模块 } else if (typeof module === 'object' &amp;&amp; typeof module.exports === 'object' ) { module.exports = factory() } else { // 直接挂载到全局对象上 global.myFn = factory() }})(window, function () { // myFn return function () { // do somethings ... }}) — The End —","link":"/js/2017/06/24/"},{"title":"nodejs 的模块规范","text":"nodejs 的模块实现，采用的是 CommonJS 的规范，每个文件就是一个模块，有自己的作用域，里面定义的变量都是私有的。 module 对象每个模块内部都有一个 module 对象，代表着当前模块。它是由 node 内部提供的 Module 构造函数实现的。 module.exports 属性module 对象有一个 exports 属性。表示当前模块对外输出的接口。其他文件加载模块，引入的就是该属性。 1234module.exports.bar = function () { // ...}module.exports.foo = 'hello' 或者可以这样写 123456module.exports = { bar: functiono () { // ... }, foo: 'hello'} 当然，你也可以直接输出一个对象、函数或者其他变量 123module.exports = function (args) { // ...} exports 变量为了方便，node 为每个模块提供了一个 exports 变量，指向 module.exports 。所以 module.exports 也简写成了 exports 1234exports.bar = function () { // ...}exports.foo = 'hello' 注意在同一文件内同时使用 exports 和 module.exports 会导致 exports 的变量无法输出；也不可直接给 exports 赋值，因为这会导致 exports 这个变量不再指向 module.exports 而输出失败！ require 命令require 是 node 的内置命令，用于加载模块。需要提供一个模块路径，默认加载 js 文件，可省略 js 后缀。 12var moduleA = require('common/js/moduleA')moduleA.foo() require 缓存node 会缓存加载的模块，所以多次 require 同一个模块会使用缓存的结果。代码在第一次加载时运行一次，然后运行结果就被缓存了。 12345var moduleA = require('common/js/moduleA')moduleA.say = function() { console.log('Hi')}require('common/js/moduleA').say() // \"Hi\" 注意，缓存是根据绝对路径识别模块的，如果同样的模块名，但是保存在不同的路径，require命令还是会重新加载该模块。删除指定模块的缓存 delete require.cache[moduleName] require 路径require 的参数可以是相对路径，也可以是绝对路径。在没有指定路径的时候 node 自动查找局部和全局安装路径。 1234var http = require('http')var server = http.createServer(function(req, res) { // ...}) — The End —","link":"/js/2017/07/01/"},{"title":"require.js 实现浏览器端模块化开发","text":"随着网页功能越来越复杂，引入的 js 脚本越来越多，加载脚本的时间越来越长，而维护这些脚本也变更困难起来。 require.js 的诞生，解决这两个问题 实现 js 脚本异步按需加载 管理模块之间的依赖关系，使代码便于维护 require.js 定义了两个函数，define 和 require ，分别用于定义模块和加载模块。 引入只需在 html 页面引入 require.js ，并用 data-main 属性指定 main.js （可省略后缀 js）入口文件（主模块）的路径就可以了。 1&lt;script src=\"lib/js/require.js\" data-main=\"js/main\"&gt;&lt;/script&gt; 主模块主模块是我们的代码开使执行的入口。有点像 C 语言的 main() 函数。里面配置了各个模块的路径。 main.js123456789101112131415require.config({ // 配置模块路径 baseUrl: 'lib/js', paths: { jquery: 'jquery.min' moduleA: 'moduleA' } // 引入非 AMD 规范的的模块使用 shim shim: { myLib: { deps: ['jquery'], exports: 'common/js/yLib' } }}) 书写 AMD 模块为了能让 require.js 加载你的模块，模块要按一定的规范书写。使用 define 函数来定义模块 moduleA 123456// 第一参数可选，表示当前模块依赖的其他模块。defined(['jquery'], function($) { return function getTime() { // do somethings }}) 兼容 CommonJS 规范AMD 规范允许输出的模块兼容 CommonJS 规范 12345678910define(function (require, exports, module) { var mA = require('moduleA') // ... exports.moduleB = { bar: 'hello', foo: function () { // ... } }}) 使用 AMD 模块使用 require 函数加载所依赖的模块，在回调函数中使用已加载的模块。 12345require(['jquery', 'moduleA'], function($, moduleA) { var imgs = $('img') var time = moduleA.getTime() // ...}) require.js 插件require.js 提供了一些插件，实现一些特定的功能，比如 domready 插件使回调函数在 DOM 解构加载完成后执行，html 插件可以让你加载 html 文件，还有 json、text、image 插件等等 1234require(['domready', 'html!template/view1.html'], function(doc, html) { console.log('document is ready now !') document.body.appendChild(html)}) — The End —","link":"/js/2017/07/08/"},{"title":"小而美的 js 片段","text":"很精辟的 js 片段，值得收藏！“防抖动” “深拷贝” “判断数据类型” “格式化时间戳” 防抖动debounce123456789101112131415161718192021222324252627282930function debounce (func, wait, immediate) { var timeout, result var debounced = function () { var context = this var args = arguments if (timeout) clearTimeout(timeout) if (immediate) { // 如果已经执行过，不再执行 var callNow = !timeout timeout = setTimeout(function () { timeout = null }, wait) if (callNow) result = func.apply(context, args) } else { timeout = setTimeout(function () { func.apply(context, args) }, wait) } return result } debounced.cancel = function () { clearTimeout(timeout) timeout = null } return debounced} 深拷贝deep copy123456789101112function deepCopy (obj) { if (obj === null || typeof obj !== 'object') return obj var newObj = obj instanceof Array ? [] : {} for (var key in obj) { if (obj.hasOwnProperty(key)) { newObj[key] = deepCopy(obj[key]) } } return newObj} 深比对123456function equalObj (o1, o2) { if (toString.call(o1) !== toString.call(o2)) return false if (typeof o1 !== 'object') return o1 === o2 if(Object.keys(o1).length !== Object.keys(o2).length) return false return Object.keys(o1).every(key =&gt; (o1[key], o2[key]))} 未考虑以下情况 1.特殊情况值 NaN // Object.is()RegExp // toString()Date // getTime()Function // toString()enumerable prop // Object.getOwnPropertyNames()Extend prop // hasOwnProperty()Error ?Native code ? 2.继承 1234var o1 = Object.create([]), o2 = Object.create({})o1 instanceof Array // falseo2 instanceof Array // trueequalObj(o1, o2) // true ?? 判断数据类型get data type1234function __type (obj) { var str = Object.prototype.toString.call(obj) return str.match(/\\[object (.*?)\\]/)[1].toLowerCase()} 格式化时间戳12345678910111213141516171819202122function formartTime (date, fmt) { if (/(y+)/.test(fmt)) { fmt = fmt.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length)) } let o = { '(M+)': date.getMonth() + 1, '(d+)': date.getDate(), '(h+)': date.getHours(), '(m+)': date.getMinutes(), '(s+)': date.getSeconds() } for (var k in o) { if (new RegExp(k).test(fmt)) { let str = o[k] + '' fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1 ? str : ('00' + str).substr(str.length))) } } return fmt} ### 12 — The End —","link":"/js/2017/06/10/"},{"title":"正则表达式语法","text":"正则基本语法整理 概述正则表达式是一种表示字符串结构的方法 以字面量的形式使用（执行效率较高） 1var regex = /xyz/igm; 使用 RegExp 构造函数（执行效率较低，但可动态传参） 12var key = 'y';var regex = new RegExp(`x${key}z`, 'igm'); RegExp.prototype 实例属性 12345678910111213141516171819202122232425262728293031// 修饰符相关(以下 3 个属性均是只读)RegExp.prototype.ignoreCase // 返回一个布尔值，表示是否设置了i修饰符。RegExp.prototype.global // 返回一个布尔值，表示是否设置了g修饰符。RegExp.prototype.multiline // 返回一个布尔值，表示是否设置了m修饰符// 返回一个数值，表示下一次开始搜索的位置RegExp.prototype.lastIndex // 该属性可读写，在进行连续匹配时，会从指定位置开始匹配RegExp.prototype.source // 返回正则表达式的字符串形式（不包括反斜杠），该属性只读。// 判断目标字符满足条件RegExp.prototype.test()var reg = /ll?/g;var count = 0;while(reg.test('hello world')) count++ // 注意与下面语句的区别 var reg = /ll?/;var count = 0;while(reg.test('hello world')) count++// 或var count = 0;while(/ll?/g.test('hello world')) count++// 获取匹配结果集, 返回匹配数组或者 nullRegExp.prototype.exec()/l(o)/.exec('hello world') // result: [\"lo\", \"o\"] // result.index: 3 匹配开始的位置// result.input: \"hello world\"// result.groups: undefined 字符串的实例与正则有关的方法 12345678910111213141516171819202122232425262728293031323334String.prototype.match() // 返回一个数组，成员是所有匹配的子字符串。'hello word'.match(/l(l)/) // [\"l\", index: 2, input: \"hello word\", groups: undefined]// 全局匹配模式 和 exec 不一样'hello word hello word'.match(/l(l)/g) // [\"ll\", \"ll\"]String.prototype.search() // 按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。String.prototype.replace() // 按照给定的正则表达式进行替换，返回替换后的字符串。// 模拟 String.trim()' hello world '.replace(/^\\s+|\\s+$/g, '') // hello world// 取掉小数点后面的零`3.0100`.replace(/(\\.?0+$)/, '') // 3.01// 格式化手机号'18579076331'.replace(/(^\\d{3})(\\d{4})(\\d{4})/, `$1 $2 $3`) // 185 7907 6331// $&amp;：匹配的子字符串。// $`：匹配结果前面的文本。// $'：匹配结果后面的文本。// $n：匹配成功的第n组内容，n是从1开始的自然数。// $$：指代美元符号$。// 英文首字母大写' hello world '.replace(/\\b\\w/g, function(match) { return match.toUpperCase()}) // 字符串分割String.prototype.split(separator, [limit])'1 2 3 4'.split(/\\s+/) // [\"1\", \"2\", \"3\", \"4\"]'1 2 3 4'.split(/\\s+/, 2) // [\"1\", \"2\"]String.prototype.split() // 按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。 匹配规则字面量字符与元字符字面量字符指的是该字符只表示它字面的含义，如 x y z。元字符指的是某些具有特殊含义字符，如下表 字符 表达式 含义 示例 点字符 . . 匹配 除 回车（\\r）、换行(\\n) 、行分隔符（\\u2028）和段分隔符（\\u2029）以外的所有字符 /he..o/.test('hello') // true 位置字符 ^ $ ^ 表示字符串的开始位置、$ 表示字符串的结束位置 /^he..o$/.test('hello') // true 选择符 | 表示“或关系” (or)包括它前后的多个字符 /he|lo/.test('hello') // true 转义字符 \\ 要匹配具有特殊含义的元字符，就要在它们前面要加上反斜杠 \\ /mi\\./.test('mi.com') // true 量词符 ? * + 用来设定某个模式出现的次数： ? 表示 0 次或 1 次、 * 表示 0 次 或 多次、 + 表示 1 次或多次 字符类用 [xyz] 表示有一系列字符可供选择，只要匹配 x y z 其中一个即可 字符 表达式 含义 示例 脱字符 ^ 表示除了字符类之中的字符，其他字符都可以匹配。 /[^mi]/.test('xiaomi') // flase 连字符 - 表示连续序列的字符范围，如 [0123456789] 可以写成 [0-9]， [A-Z] 或 [\\u0041-\\u005a] 表示26个大写字母 /[a-z]/.test('b') // true 脱字符 [^] 可匹配一切字符，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面量字符 连字符 - 只有在字符类中，并且是两个连续字符之间才有特殊含义，否则就是字面量字符。如 /a-z/.test('b') // false， [z-a] 是不合法的表达式，[-a] 表达式里的 - 是字面量字符 预定义模式预定义模式指的是某些常见模式的简写方式 表达式 含义 示例 \\d 匹配0-9之间的任一数字字符类 相当于 [0-9] \\D 匹配所有0-9以外的字符字符类 相当于 [^0-9] \\w 匹配任意的字母、数字和下划线字符类 相当于 [A-Za-z0-9_] \\W 除所有字母、数字和下划线以外的字符 相当于 [^A-Za-z0-9_] \\s 匹配空格（包括换行符、制表符、空格符等) 相当于 [ \\t\\r\\n\\v\\f] \\S 匹配非空格的字符 相当于 [^ \\t\\r\\n\\v\\f] \\b 匹配词的边界 \\B 匹配非词边界，即在词的内部 重复类模式的精确匹配次数，使用大括号{}表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n, m}表示重复不少于n次，不多于m次。 量词符 符号 含义 ? 问号表示某个模式出现0次或1次，等同于{0, 1}。 * 星号表示某个模式出现0次或多次，等同于{0,}。 + 加号表示某个模式出现1次或多次，等同于{1,}。 * + 默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式 12'aaaaa'.match(/a+/) // [\"aaaaa\", index: 0, input: \"aaaaa\", groups: undefined]// 使用 +? *? 改成非贪婪匹配，效果和单独使用 ? 一样。。。？？ 特殊字符正则表达式对一些不能打印的特殊字符，提供了表达方法 字符 表达式 含义 示例 控制字符（Ctrl + [key]） \\cX 表示控制键（Ctrl）和 a-z 任意字母的组合键 ？？ 退格键(U+0008) [\\b] 不要与 \\b 混淆 /[\\b]/.test('\\u0008') // true 换行键 \\n 匹配 new line（换行） /\\n/.test('\\u000a') // true 回车键 \\r 匹配 Enter 键 /\\r/.test('\\u000d') // true 制表符 \\t 匹配 tab 键 /\\t/.test('\\u0009') // true 垂直制表符 \\v 匹配 ？？ /\\v/.test('\\u25??') 换页符 \\f 匹配 ？？ /\\f/.test('\\u000c') // true null字符 \\0 匹配 null ？？ /\\0/.test('\\u0000') // true ？？ \\xhh 匹配一个以两位十六进制数（\\x00-\\xFF）表示的字符 ？？ ？？ \\uhhhh 匹配一个以四位十六进制数（\\u0000-\\uFFFF）表示的 Unicode 字符 ？？ 三种修饰符 i g m 可组合使用 ignorecase：忽略英文字母大小写 global：连续匹配（全局匹配），匹配全部符合条件的结果，主要用于搜索和替换。str.search(/xx/g) str.match(/xx/g) reg.exec(str) 等方法里常见 multiline：会修改^和$的行为，即^和$会识别换行12/^abc$/.test('\\nabc\\n') // false/^abc$/m.test('\\nabc\\n') // true 组匹配正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容 注意使用组匹配时，不宜同时使用g修饰符，否则match方法不会捕获分组的内容。 12'abcabc'.match(/(.)b(.)/); // [\"abc\", \"a\", \"c\", index: 0, input: \"abcabc\", groups: undefined]// [匹配命中字符串, 匹配组, ...] 匹配组引用 对成对出现的字符使用 12/&lt;([^&gt;]+)&gt;[^&lt;]*&lt;\\/\\1&gt;/.exec(\"&lt;b&gt;bold&lt;/b&gt;\")[1]) // b` 非匹配组 12345678910// 正常匹配var url = /(http|ftp):\\/\\/([^/\\r\\n]+)(\\/[^\\r\\n]*)?/;url.exec('http://google.com/');// [\"http://google.com/\", \"http\", \"google.com\", \"/\"]// 非捕获组匹配var url = /(?:http|ftp):\\/\\/([^/\\r\\n]+)(\\/[^\\r\\n]*)?/;url.exec('http://google.com/'); 先行断言 (?=x) 与 先行否定断言 (?!y)12'abd'.match(/b(?!c)/); // [\"b\"] 'abc'.match(/b(?=c)/); // [\"b\"] 附录 字符类 [A-z] 表示的范围是？ 字符类 [0-100] 表示的范围是？ 如何匹配所有字符 ？ 12new RegExp('')/\\s\\S/ 解析模板字符串 12345678910111213141516var info = { name: 'zyy', old: '0.7', address: 'china', sex: 'boy' };var html = `&lt;ul&gt; &lt;li&gt;姓名：{{name}}&lt;/li&gt; &lt;li&gt;性别：{{sex}}&lt;/li&gt; &lt;li&gt;年龄：{{old}}&lt;/li&gt; &lt;li&gt;住址：{{address}}&lt;/li&gt; &lt;/ul&gt;`;var reg = /\\{\\{(.*?)\\}\\}/; var result = null;while(result = reg.exec(html)) { reg.lastIndex = 0 html = html.replace(reg, info[result[1]])}document.write(html)` — The End —","link":"/js/2017/05/27/"},{"title":"标准 js 的书写规范","text":"这是一篇 js 代码规范的文章，教你如何书写漂亮的 js 代码。文章摘自 github 细则 使用两个空格进行缩进。 eslint: indent 123function hello (name) { console.log('hi', name)} 除需要转义的情况外，字符串统一使用单引号。 eslint: quotes 12console.log('hello there')$(\"&lt;div class='box'&gt;\") 不要定义未使用的变量。 eslint: no-unused-vars 123function myFunction () { var result = something() // ✗ avoid} 关键字后面加空格。 eslint: keyword-spacing 12if (condition) { ... } // ✓ okif(condition) { ... } // ✗ avoid 函数声明时括号与函数名间加空格。 eslint: space-before-function-paren 12345function name (arg) { ... } // ✓ okfunction name(arg) { ... } // ✗ avoidrun(function () { ... }) // ✓ okrun(function() { ... }) // ✗ avoid 始终使用 === 替代 ==。例外： obj == null 可以用来检查 null || undefined。 eslint: eqeqeq 12if (name === 'John') // ✓ okif (name == 'John') // ✗ avoid 12if (name !== 'John') // ✓ okif (name != 'John') // ✗ avoid 字符串拼接操作符 (Infix operators) 之间要留空格。 eslint: space-infix-ops 123// ✓ okvar x = 2var message = 'hello, ' + name + '!' 123// ✗ avoidvar x=2var message = 'hello, '+name+'!' 逗号后面加空格。 eslint: comma-spacing 123// ✓ okvar list = [1, 2, 3, 4]function greet (name, options) { ... } 123// ✗ avoidvar list = [1,2,3,4]function greet (name,options) { ... } else 关键字要与花括号保持在同一行。 eslint: brace-style 123456// ✓ okif (condition) { // ...} else { // ...} 123456789// ✗ avoidif (condition){ // ...}else{ // ...} 多行 if 语句的的括号不能省。 eslint: curly 12// ✓ okif (options.quiet !== true) console.log('done') 1234// ✓ okif (options.quiet !== true) { console.log('done')} 123// ✗ avoidif (options.quiet !== true) console.log('done') 不要丢掉异常处理中err参数。 eslint: handle-callback-err 12345// ✓ okrun(function (err) { if (err) throw err window.alert('done')}) 1234// ✗ avoidrun(function (err) { window.alert('done')}) 使用浏览器全局变量时加上 window. 前缀。Exceptions are: document, console and navigator. eslint: no-undef 1window.alert('hi') // ✓ ok 不允许有连续多行空行。 eslint: no-multiple-empty-lines 123// ✓ okvar value = 'hello world'console.log(value) 12345// ✗ avoidvar value = 'hello world'console.log(value) 对于三元运算符 ? 和 : 与他们所负责的代码处于同一行 eslint: operator-linebreak 123456789101112// ✓ okvar location = env.development ? 'localhost' : 'www.api.com'// ✓ okvar location = env.development ? 'localhost' : 'www.api.com'// ✗ avoidvar location = env.development ? 'localhost' : 'www.api.com' 每个 var 关键字单独声明一个变量。 eslint: one-var 12345678910// ✓ okvar silent = truevar verbose = true// ✗ avoidvar silent = true, verbose = true// ✗ avoidvar silent = true, verbose = true 条件语句中赋值语句使用括号包起来。这样使得代码更加清晰可读，而不会认为是将条件判断语句的全等号（===）错写成了等号（=）。 eslint: no-cond-assign 123456789// ✓ okwhile ((m = text.match(expr))) { // ...}// ✗ avoidwhile (m = text.match(expr)) { // ...} 单行代码块两边加空格。 eslint: block-spacing 12function foo () {return true} // ✗ avoidfunction foo () { return true } // ✓ ok 对于变量和函数名统一使用驼峰命名法。 eslint: camelcase 12345function my_function () { } // ✗ avoidfunction myFunction () { } // ✓ okvar my_var = 'hello' // ✗ avoidvar myVar = 'hello' // ✓ ok 不允许有多余的行末逗号。 eslint: comma-dangle 123var obj = { message: 'hello', // ✗ avoid} 始终将逗号置于行末。 eslint: comma-style 123456789var obj = { foo: 'foo' ,bar: 'bar' // ✗ avoid}var obj = { foo: 'foo', bar: 'bar' // ✓ ok} 点号操作符须与属性需在同一行。 eslint: dot-location 12345console. log('hello') // ✗ avoidconsole .log('hello') // ✓ ok 文件末尾留一空行。 eslint: eol-last 函数调用时标识符与括号间不留间隔。 eslint: func-call-spacing 12console.log ('hello') // ✗ avoidconsole.log('hello') // ✓ ok 键值对当中冒号与值之间要留空白。 eslint: key-spacing 1234var obj = { 'key' : 'value' } // ✗ avoidvar obj = { 'key' :'value' } // ✗ avoidvar obj = { 'key':'value' } // ✗ avoidvar obj = { 'key': 'value' } // ✓ ok 构造函数要以大写字母开头。 eslint: new-cap 12345function animal () {}var dog = new animal() // ✗ avoidfunction Animal () {}var dog = new Animal() // ✓ ok 无参的构造函数调用时要带上括号。 eslint: new-parens 123function Animal () {}var dog = new Animal // ✗ avoidvar dog = new Animal() // ✓ ok 对象中定义了存值器，一定要对应的定义取值器。 eslint: accessor-pairs 1234567891011121314var person = { set name (value) { // ✗ avoid this._name = value }}var person = { set name (value) { this._name = value }, get name () { // ✓ ok return this._name }} 子类的构造器中一定要调用 super eslint: constructor-super 1234567891011class Dog { constructor () { super() // ✗ avoid }}class Dog extends Mammal { constructor () { super() // ✓ ok }} 使用数组字面量而不是构造器。 eslint: no-array-constructor 12var nums = new Array(1, 2, 3) // ✗ avoidvar nums = [1, 2, 3] // ✓ ok 避免使用 arguments.callee 和 arguments.caller。 eslint: no-caller 1234567891011function foo (n) { if (n &lt;= 0) return arguments.callee(n - 1) // ✗ avoid}function foo (n) { if (n &lt;= 0) return foo(n - 1)} 避免对类名重新赋值。 eslint: no-class-assign 12class Dog {}Dog = 'Fido' // ✗ avoid 避免修改使用 const 声明的变量。 eslint: no-const-assign 12const score = 100score = 125 // ✗ avoid 避免使用常量作为条件表达式的条件（循环语句除外）。 eslint: no-constant-condition 1234567891011if (false) { // ✗ avoid // ...}if (x === 0) { // ✓ ok // ...}while (true) { // ✓ ok // ...} 正则中不要使用控制符。 eslint: no-control-regex 12var pattern = /\\x1f/ // ✗ avoidvar pattern = /\\x20/ // ✓ ok 不要使用 debugger。 eslint: no-debugger 1234function sum (a, b) { debugger // ✗ avoid return a + b} 不要对变量使用 delete 操作。 eslint: no-delete-var 12var namedelete name // ✗ avoid 不要定义冗余的函数参数。 eslint: no-dupe-args 1234567function sum (a, b, a) { // ✗ avoid // ...}function sum (a, b, c) { // ✓ ok // ...} 类中不要定义冗余的属性。 eslint: no-dupe-class-members 1234class Dog { bark () {} bark () {} // ✗ avoid} 对象字面量中不要定义重复的属性。 eslint: no-dupe-keys 1234var user = { name: 'Jane Doe', name: 'John Doe' // ✗ avoid} switch 语句中不要定义重复的 case 分支。 eslint: no-duplicate-case 12345switch (id) { case 1: // ... case 1: // ✗ avoid} 同一模块有多个导入时一次性写完。 eslint: no-duplicate-imports 1234import { myFunc1 } from 'module'import { myFunc2 } from 'module' // ✗ avoidimport { myFunc1, myFunc2 } from 'module' // ✓ ok 正则中不要使用空字符。 eslint: no-empty-character-class 12const myRegex = /^abc[]/ // ✗ avoidconst myRegex = /^abc[a-z]/ // ✓ ok 不要解构空值。 eslint: no-empty-pattern 12const { a: {} } = foo // ✗ avoidconst { a: { b } } = foo // ✓ ok 不要使用 eval()。 eslint: no-eval 12eval( \"var result = user.\" + propName ) // ✗ avoidvar result = user[propName] // ✓ ok catch 中不要对错误重新赋值。 eslint: no-ex-assign 1234567891011try { // ...} catch (e) { e = 'new value' // ✗ avoid}try { // ...} catch (e) { const newVal = 'new value' // ✓ ok} 不要扩展原生对象。 eslint: no-extend-native 1Object.prototype.age = 21 // ✗ avoid 避免多余的函数上下文绑定。 eslint: no-extra-bind 1234567const name = function () { getName()}.bind(user) // ✗ avoidconst name = function () { this.getName()}.bind(user) // ✓ ok 避免不必要的布尔转换。 eslint: no-extra-boolean-cast 123456789const result = trueif (!!result) { // ✗ avoid // ...}const result = trueif (result) { // ✓ ok // ...} 不要使用多余的括号包裹函数。 eslint: no-extra-parens 12const myFunc = (function () { }) // ✗ avoidconst myFunc = function () { } // ✓ ok switch 一定要使用 break 来将条件分支正常中断。 eslint: no-fallthrough 12345678910111213141516171819202122switch (filter) { case 1: doSomething() // ✗ avoid case 2: doSomethingElse()}switch (filter) { case 1: doSomething() break // ✓ ok case 2: doSomethingElse()}switch (filter) { case 1: doSomething() // fallthrough // ✓ ok case 2: doSomethingElse()} 不要省去小数点前面的0。 eslint: no-floating-decimal 12const discount = .5 // ✗ avoidconst discount = 0.5 // ✓ ok 避免对声明过的函数重新赋值。 eslint: no-func-assign 12function myFunc () { }myFunc = myOtherFunc // ✗ avoid 不要对全局只读对象重新赋值。 eslint: no-global-assign 1window = {} // ✗ avoid 注意隐式的 eval()。 eslint: no-implied-eval 12setTimeout(\"alert('Hello world')\") // ✗ avoidsetTimeout(function () { alert('Hello world') }) // ✓ ok 嵌套的代码块中禁止再定义函数。 eslint: no-inner-declarations 123if (authenticated) { function setAuthUser () {} // ✗ avoid} 不要向 RegExp 构造器传入非法的正则表达式。 eslint: no-invalid-regexp 12RegExp('[a-z') // ✗ avoidRegExp('[a-z]') // ✓ ok 不要使用非法的空白符。 eslint: no-irregular-whitespace 1function myFunc () /*&lt;NBSP&gt;*/{} // ✗ avoid 禁止使用 __iterator__。 eslint: no-iterator 1Foo.prototype.__iterator__ = function () {} // ✗ avoid 外部变量不要与对象属性重名。 eslint: no-label-var 12345678var score = 100function game () { score: while (true) { // ✗ avoid score -= 10 if (score &gt; 0) continue score break }} 不要使用标签语句。 eslint: no-labels 1234label: while (true) { break label // ✗ avoid } 不要书写不必要的嵌套代码块。 eslint: no-lone-blocks 123456789function myFunc () { { // ✗ avoid myOtherFunc() }}function myFunc () { myOtherFunc() // ✓ ok} 不要混合使用空格与制表符作为缩进。 eslint: no-mixed-spaces-and-tabs 除了缩进，不要使用多个空格。 eslint: no-multi-spaces 12const id = 1234 // ✗ avoidconst id = 1234 // ✓ ok 不要使用多行字符串。 eslint: no-multi-str 12const message = 'Hello \\ world' // ✗ avoid new 创建对象实例后需要赋值给变量。 eslint: no-new 12new Character() // ✗ avoidconst character = new Character() // ✓ ok 禁止使用 Function 构造器。 eslint: no-new-func 1var sum = new Function('a', 'b', 'return a + b') // ✗ avoid 禁止使用 Object 构造器。 eslint: no-new-object 1let config = new Object() // ✗ avoid 禁止使用 new require。 eslint: no-new-require 1const myModule = new require('my-module') // ✗ avoid 禁止使用 Symbol 构造器。 eslint: no-new-symbol 1const foo = new Symbol('foo') // ✗ avoid 禁止使用原始包装器。 eslint: no-new-wrappers 1const message = new String('hello') // ✗ avoid 不要将全局对象的属性作为函数调用。 eslint: no-obj-calls 1const math = Math() // ✗ avoid 不要使用八进制字面量。 eslint: no-octal 12const num = 042 // ✗ avoidconst num = '042' // ✓ ok 字符串字面量中也不要使用八进制转义字符。 eslint: no-octal-escape 1const copyright = 'Copyright \\251' // ✗ avoid 使用 __dirname 和 __filename 时尽量避免使用字符串拼接。 eslint: no-path-concat 12const pathToFile = __dirname + '/app.js' // ✗ avoidconst pathToFile = path.join(__dirname, 'app.js') // ✓ ok 使用 getPrototypeOf 来替代 __proto__。 eslint: no-proto 12const foo = obj.__proto__ // ✗ avoidconst foo = Object.getPrototypeOf(obj) // ✓ ok 不要重复声明变量。 eslint: no-redeclare 12345let name = 'John'let name = 'Jane' // ✗ avoidlet name = 'John'name = 'Jane' // ✓ ok 正则中避免使用多个空格。 eslint: no-regex-spaces 1234const regexp = /test value/ // ✗ avoidconst regexp = /test {3}value/ // ✓ okconst regexp = /test value/ // ✓ ok return 语句中的赋值必需有括号包裹。 eslint: no-return-assign 1234567function sum (a, b) { return result = a + b // ✗ avoid}function sum (a, b) { return (result = a + b) // ✓ ok} 避免将变量赋值给自己。 eslint: no-self-assign 1name = name // ✗ avoid 避免将变量与自己进行比较操作。 esint: no-self-compare 1if (score === score) {} // ✗ avoid 避免使用逗号操作符。 eslint: no-sequences 1if (doSomething(), !!test) {} // ✗ avoid 不要随意更改关键字的值。 eslint: no-shadow-restricted-names 1let undefined = 'value' // ✗ avoid 禁止使用稀疏数组（Sparse arrays）。 eslint: no-sparse-arrays 1let fruits = ['apple',, 'orange'] // ✗ avoid 不要使用制表符。 eslint: no-tabs 正确使用 ES6 中的字符串模板。 eslint: no-template-curly-in-string 12const message = 'Hello ${name}' // ✗ avoidconst message = `Hello ${name}` // ✓ ok 使用 this 前请确保 super() 已调用。 eslint: no-this-before-super 123456class Dog extends Animal { constructor () { this.legs = 4 // ✗ avoid super() }} 用 throw 抛错时，抛出 Error 对象而不是字符串。 eslint: no-throw-literal 12throw 'error' // ✗ avoidthrow new Error('error') // ✓ ok 行末不留空格。 eslint: no-trailing-spaces 不要使用 undefined 来初始化变量。 eslint: no-undef-init 1234let name = undefined // ✗ avoidlet namename = 'value' // ✓ ok 循环语句中注意更新循环变量。 eslint: no-unmodified-loop-condition 12for (let i = 0; i &lt; items.length; j++) {...} // ✗ avoidfor (let i = 0; i &lt; items.length; i++) {...} // ✓ ok 如果有更好的实现，尽量不要使用三元表达式。 eslint: no-unneeded-ternary 12let score = val ? val : 0 // ✗ avoidlet score = val || 0 // ✓ ok return，throw，continue 和 break 后不要再跟代码。 eslint: no-unreachable 1234function doSomething () { return true console.log('never called') // ✗ avoid} finally 代码块中不要再改变程序执行流程。 eslint: no-unsafe-finally 1234567try { // ...} catch (e) { // ...} finally { return 42 // ✗ avoid} 关系运算符的左值不要做取反操作。 eslint: no-unsafe-negation 1if (!key in obj) {} // ✗ avoid 避免不必要的 .call() 和 .apply()。 eslint: no-useless-call 1sum.call(null, 1, 2, 3) // ✗ avoid 避免使用不必要的计算值作对象属性。 eslint: no-useless-computed-key 12const user = { ['name']: 'John Doe' } // ✗ avoidconst user = { name: 'John Doe' } // ✓ ok 禁止多余的构造器。 eslint: no-useless-constructor 1234class Car { constructor () { // ✗ avoid }} 禁止不必要的转义。 eslint: no-useless-escape 1let message = 'Hell\\o' // ✗ avoid import, export 和解构操作中，禁止赋值到同名变量。 eslint: no-useless-rename 12import { config as config } from './config' // ✗ avoidimport { config } from './config' // ✓ ok 属性前面不要加空格。 eslint: no-whitespace-before-property 12user .name // ✗ avoiduser.name // ✓ ok 禁止使用 with。 eslint: no-with 1with (val) {...} // ✗ avoid 对象属性换行时注意统一代码风格。 eslint: object-property-newline 123456789101112const user = { name: 'Jane Doe', age: 30, username: 'jdoe86' // ✗ avoid}const user = { name: 'Jane Doe', age: 30, username: 'jdoe86' } // ✓ okconst user = { name: 'Jane Doe', age: 30, username: 'jdoe86'} // ✓ ok 代码块中避免多余留白。 eslint: padded-blocks 123456789if (user) { // ✗ avoid const name = getName()}if (user) { const name = getName() // ✓ ok} 展开运算符与它的表达式间不要留空白。 eslint: rest-spread-spacing 12fn(... args) // ✗ avoidfn(...args) // ✓ ok 遇到分号时空格要后留前不留。 eslint: semi-spacing 12for (let i = 0 ;i &lt; items.length ;i++) {...} // ✗ avoidfor (let i = 0; i &lt; items.length; i++) {...} // ✓ ok 代码块首尾留空格。 eslint: space-before-blocks 12if (admin){...} // ✗ avoidif (admin) {...} // ✓ ok 圆括号间不留空格。 eslint: space-in-parens 12getName( name ) // ✗ avoidgetName(name) // ✓ ok 一元运算符后面跟一个空格。 eslint: space-unary-ops 12typeof!admin // ✗ avoidtypeof !admin // ✓ ok 注释首尾留空格。 eslint: spaced-comment 12345//comment // ✗ avoid// comment // ✓ ok/*comment*/ // ✗ avoid/* comment */ // ✓ ok 模板字符串中变量前后不加空格。 eslint: template-curly-spacing 12const message = `Hello, ${ name }` // ✗ avoidconst message = `Hello, ${name}` // ✓ ok 检查 NaN 的正确姿势是使用 isNaN()。 eslint: use-isnan 12if (price === NaN) { } // ✗ avoidif (isNaN(price)) { } // ✓ ok 用合法的字符串跟 typeof 进行比较操作。 eslint: valid-typeof 12typeof name === 'undefimed' // ✗ avoidtypeof name === 'undefined' // ✓ ok 自调用匿名函数 (IIFEs) 使用括号包裹。 eslint: wrap-iife 1234const getName = function () { }() // ✗ avoidconst getName = (function () { }()) // ✓ okconst getName = (function () { })() // ✓ ok yield * 中的 * 前后都要有空格。 eslint: yield-star-spacing 12yield* increment() // ✗ avoidyield * increment() // ✓ ok 请书写优雅的条件语句（avoid Yoda conditions）。 eslint: yoda 12if (42 === age) { } // ✗ avoidif (age === 42) { } // ✓ ok 关于分号 不要使用分号。 (参见：1，2，3) eslint: semi 12window.alert('hi') // ✓ okwindow.alert('hi'); // ✗ avoid 不要使用 (, [, or ` 等作为一行的开始。在没有分号的情况下代码压缩后会导致报错，而坚持这一规范则可避免出错。 eslint: no-unexpected-multiline 123456789// ✓ ok;(function () { window.alert('ok')}())// ✗ avoid(function () { window.alert('ok')}()) 12345// ✓ ok;[1, 2, 3].forEach(bar)// ✗ avoid[1, 2, 3].forEach(bar) 12345// ✓ ok;`hello`.indexOf('o')// ✗ avoid`hello`.indexOf('o') 备注：上面的写法只能说聪明过头了。 相比更加可读易懂的代码，那些看似投巧的写法是不可取的。 譬如： 1;[1, 2, 3].forEach(bar) 建议的写法是： 12var nums = [1, 2, 3]nums.forEach(bar) 拓展阅读 An Open Letter to JavaScript Leaders Regarding Semicolons JavaScript Semicolon Insertion – Everything you need to know 一个值得观看的视频： JavaScript 中的分号多余吗？- YouTube 当前主流的代码压缩方案都是基于词法（AST-based）进行的，所以在处理无分号的代码时完全没有压力（何况 JavaScript 中分号本来就不是强制的）。 一段摘抄自 “An Open Letter to JavaScript Leaders Regarding Semicolons” 这篇文章的内容： [自动化插入分号的做法]是安全可依赖的，而且其产出的代码能够在所有浏览器里很好地运行。 Closure compiler, yuicompressor, packer 还有 jsmin 都能正确地对这样的代码进行压缩处理。并没有任何性能相关的问题。 不得不说，Javascript 社区里的大牛们一直是错误的，并不能教给你最佳实践。真是让人忧伤啊。 我建议先弄清楚 JS 是怎样断句的（还有就是哪些地方看起来断了其实并没有），明白了这个后就可以随心写出漂亮的代码了。 一般来说， \\n 表示语句结束，除非： 该语句有未闭合的括号， 数组字面量， 对象字面量 或者其他不能正常结束一条语句的情况（譬如，以 . 或 , 结尾） 该语句是 -- 或者 ++ （它会将后面的内容进行自增或减） 该语句是 for()，while()，do，if() 或者 else 并且没有 { 下一行以 [，(，+，*，/，-，,，. 或者其他只会单独出现在两块内容间的二元操作符。 第一条很容易理解。即使在 JSLint 中，也允许 JSON，构造器的括号中，以及使用 var 配合 , 结尾来声明多个变量等这些情中包含 \\n。 第二条有点奇葩。 我还想不出谁会（除了这里用作讨论外）写出 i\\n++\\nj 这样的代码来，不过，顺便说一下，这种写法最后解析的结果是 i; ++j，而不是 i++; j。 第三条也容易理解。 if (x)\\ny() 等价于 if (x) { y() }。解释器会向下寻找到代码块或一条语句为止。 ; 是条合法的 JavaScript 语句。所以 if(x); 等价于 if(x){}，表示 “如果 x 为真，什么也不做。” 这种写法在循环里面可以看到，就是当条件判断与条件更新是同一个方法的时候。 不常见，但也不至于没听说过吧。 第四条就是常见的 “看，说过要加分号！” 的情形。但这些情况可以通过在语句前面加上分号来解决，如果你确定该语句跟前面的没关系的话。举个例子，假如你想这样： 123&gt; foo();&gt; [1,2,3].forEach(bar);&gt; 那么完全可以这样来写： 123&gt; foo()&gt; ;[1,2,3].forEach(bar)&gt; 后者的好处是分号比较瞩目，一旦习惯后便再也不会看到以 ( 和 [ 开头又不带分号的语句了。","link":"/js/2017/04/08/"},{"title":"js 中的 void 操作符","text":"也许你见过 &lt;a href=&quot;javascript:void(0)&quot;&gt;link&lt;/a&gt; 这种写法，这种写法的目的是什么呢？或者说 void 是什么？ void 运算符的作用是执行一个表达式，然后不返回任何值，或者说返回 undefined。 void 的特点void 后面的是表达式12void 4 // undefinedvoid (7 + 3) // undefined void 运算的优先级更高1void 7 * 3 // NaN 立即执行函数表达式void 运算符让 JavaScript 引擎把一个function关键字识别成函数表达式而不是函数声明 123456void function f() { console.log(1) }()// 1// undefinedf() // Uncaught ReferenceError: f is not defined void 的应用获得 真正的 undefinedundefined 不是保留字，在 IE6、7、8 里面，undefined 是可以被当作变量赋值的，用 void 可以确保获取真正的 undefined 1234var undefined = 10if (a === void(0)) { // do somethings} 利用闭包也可以获取真正的 undefined 123(function (global, undefined) { typeof a === undefined // true})(window) javascript URI在火狐浏览器中，当用户点击一个以 javascript: URI 时，当返回值不是 undefined 时，页面会被替换成返回值（chrome 不会） 12&lt;a href=\"javascript:0\"&gt;link&lt;/a&gt; // 页面替换成 0&lt;a href=\"javascript: (function() { return null }())\"&gt;link&lt;/a&gt; // 页面替换成 null 而 void 操作返回 undefined ，所以你能看到如下写法 1&lt;a href=\"javascript:void(0)\" onclick=\"onClickLink()\"&gt;link&lt;/a&gt; 要实现上诉效果，下面这 3 种写法也是可以的 123&lt;a href=\"javascript:\" onclick=\"onClickLink()\"&gt;link&lt;/a&gt;&lt;a href=\"javascript:;\" onclick=\"onClickLink()\"&gt;link&lt;/a&gt;&lt;a href=\"##\" onclick=\"onClickLink()\"&gt;link&lt;/a&gt; — The End —","link":"/js/2017/04/22/"},{"title":"webview 开发的哪些坑。。。","text":"使用原生应用的壳，内容使用 webview 呈现，这种开发模式不但可以节省开发成本，功能更新也可以不用让用户升级客户端。但性能和纯原生比较还是有较大差距！而从浏览器环境到 webview ，采坑无数。。。 window 的 resize 事件为了实现表单输入框不被软键盘遮挡，键盘弹出是，窗口的高度会变化，监听 window 的 resize 事件，使用 API scrollIntoViewIfNeededscrollIntoView 滚动表单到屏幕可视区。结果没有执行！起初以为 webview 不支持该 API ，后来发现是 resize 事件没有触发。。。后来原生修复了该 bug webkitRequestFullScreen使用 photoSwipe 预览图片，全屏预览时直接卡死！原生的解释是：不支持该 API 附件上传&lt;input type=&quot;file&quot;&gt; 只能选择图片。后来原生解决了该问题，IOS 没有文件管理系统，至少 Android 是可以上传的。 附件下载使用 &lt;a href=&quot;xxx.jpg&quot; download&gt; 下载图片，会打开其他浏览器进行下载。原生的解释是需要开发下载模块才能下载，但对于 IOS 的沙盒机制限制，仍然无法下载。 — The End —","link":"/js/2018/01/06/"},{"title":"搜集常用的正则表达式","text":"收集常用的正则表单式，方便工作中使用。 Web 匹配 URL 协议、域、端口及路径： /(\\w+):\\/\\/([^/:]+)(:\\d)?([^# ])/ 匹配 email 地址： /[\\w!#$%&amp;’+/=?^_`{|}~-]+(?:.[\\w!#$%&amp;’+/=?^_`{|}~-]+)@(?:[\\w](?:[\\w-][\\w])?.)+\\w?/ Number 匹配小数末尾的无效 0： /.?0+$/ 匹配数字： /-?^\\d+(.\\d+)?$/ 匹配 qq 号：/[1-9][0-9]{4,}/ 匹配 18 位身份证号码：/^(\\d{6})(\\d{4})(\\d{2})(\\d{2})(\\d{3})([0-9]|X)$/ 格式化数值带千分位符 ‘123456789’.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ‘,’) DOM 匹配双标签 html： /&lt;\\s(\\S+)(\\s[^&gt;])?&gt;[\\s\\S]&lt;\\s\\/\\1\\s*&gt;/ text 匹配空行： /^\\s*$/ 匹配中文字符： /[\\u4e00-\\u9fa5]/ 匹配双字节字符：/[^\\x00-\\xff]/ — The End —","link":"/js/2017/06/03/"},{"title":"fetch 对象","text":"— The End —","link":"/js/2017/03/25/"},{"title":"原生的 XMLHttpRequest 对象","text":"1999年，微软公司发布 IE 浏览器5.0版，第一次引入新功能：允许 JavaScript 脚本向服务器发起 HTTP 请求（通过 ActiveXObject 对象），预示 Ajax 的诞生。在各大互联公司的共同推进下，W3C在2006年发布了它的国际标准，从此 AJAX（Asynchronous JavaScript and XML） 就成为 JavaScript 脚本发起 HTTP 通信的代名词。 — The End —","link":"/js/2017/03/18/"},{"title":"linux 磁盘","text":"linux 磁盘分区、格式化、挂载 磁盘两种分区模式MBR 最多支持 4 个主分区 系统引导自能安装在主分区 扩展分区要占用一个主分区 分区最大支持 2TB 兼容性好 windows MBR 分区示意 GPT 主分区数量无限制（windows 最多支持 128 个分区） 分区支持 18EB （1024 * 1024TB） win7 开始支持 linux 磁盘linux 硬盘分为 IDE（ATA）、SCSI 硬盘，目前基本上是 SCSI 硬盘 在 linux shell 中输入 lsblk 查看当前系统磁盘分区及挂载情况: NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 20G 0 disk ├sda1 8:1 0 1G 0 part /boot └sda2 8:2 0 19G 0 part ├centos-root 253:0 0 17G 0 lvm / └centos-swap 253:1 0 2G 0 lvm [SWAP] sdb 8:16 0 2G 0 disk └sdb1 8:17 0 2G 0 part sr0 11:0 1 1024M 0 rom IDE 的硬盘标识符是 hd 开头，SCSI 硬盘标识符是 sd 开头。上表中有两个 SCSI 硬盘 —— sda 、sdb ，其中 sda 有两个分区 sda1 、 sda2 ；sdb 有一个分区 sdb1 。sr0 是光驱 标识符 含义 sda SCSI 基本盘 sdb SCSI 基本从属盘 sdc SCSI 辅助主盘 sdd SCSI 辅助从属盘 IDE 硬盘标识符 hd 开头，其余参数和 sd 表示方法一样 对于 MBR 分区模式的硬盘，前四个分区用数字 1~4 结尾，表示主分区或者扩展分区，从 5 开始才是逻辑分区 linux 的根目录只有一个，是一个独立且唯一的文档结构。linux 中的每个分区都是用来组成整个文件系统的一部分，采用“载入”的方式将每个分区和目录联系起来。例如上图的 sda1 分区挂载为文件系统内的 /boot 文件夹。 分区操作添加磁盘后，一般需要重启系统才能检测到新添加的磁盘。没有被格式化之前是挂载不了的。 磁盘添加成功后，出现在 /dev 目录下，使用 fdisk 工具进行分区、格式化 假设新添加的磁盘的标识符是 sdc ，计划挂载到 /home/sdc 目录下 分区shell 中输入 fdisk /dev/sdc ，再输入 m 获取帮助菜单，将进入命令交互 命令操作 a toggle a bootable flag b edit bsd disklabel c toggle the dos compatibility flag d delete a partition g create a new empty GPT partition table G create an IRIX (SGI) partition table l list known partition types m print this menu n add a new partition o create a new empty DOS partition table p print the partition table q quit without saving changes s create a new empty Sun disklabel t change a partition's system id u change display/entry units v verify the partition table w write table to disk and exit x extra functionality (experts only) 命令(输入 m 获取帮助)： 输入 n 添加分区，这里我们采用默认设置，一路回车即可。 完成后输入 p 可以查看当前磁盘的分区情况。 磁盘 /dev/sdc：1073 MB, 1073741824 字节，2097152 个扇区 Units = 扇区 of 1 * 512 = 512 bytes 扇区大小(逻辑/物理)：512 字节 / 512 字节 I/O 大小(最小/最佳)：512 字节 / 512 字节 磁盘标签类型：dos 磁盘标识符：0x748ddcdd 设备 Boot Start End Blocks Id System /dev/sdc1 2048 2097151 1047552 83 Linux 分区完成后要输入 w 才会将分区配置写入磁盘。 格式化把 sdc1 分区格式化成 ext4 类型的文件系统 shell 中输入 mkfs -t ext4 /dev/sdc1 挂载到 /home/sdcshell 中输入 mount /dev/sdc1 /home/sdc 执行挂载操作 挂载成功后输入 lsblk 查看挂载情况 NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT ... sdc 8:32 0 1G 0 disk └─sdc1 8:33 0 1023M 0 part /home/sdc ... 重启自动挂载编辑 /dev/fstab 文件 加入一行 /dev/sdc1 /home/sdc ext4 defaults 0 0 再输入 mount -a 可使修改即刻生效 挂载后卸载1umount /home/sdc — The End —","link":"/linux/2018/05/05/"},{"title":"linux 下的 /etc/group 文件","text":"linux group 文件保存着组的配置信息，看看都记录了啥。 在 linux 命令行输入 1vim /etc/group 如下是文件内容 看最后一行记录的是组 dev 的信息 dev:x:1007: 解读下含义如下 dev 组名 x 组的口令（加密） 1007 组 ID 有哪些用户属于这个组，隐藏（最后一个冒号后面） 即 组名 : 组口令 : 组ID : 组内用户 — The End —","link":"/linux/2018/04/15/"},{"title":"linux 下的 /etc/passwd 文件","text":"linux passwd 文件保存着用户的密码信息（密码是加密的）和登录信息，打开该文件，看看都记录了啥。 在 linux 命令行输入 1vim /etc/passwd 如下是文件内容 看最后一行记录的是用户 John 的信息，使用 : 分割不同的信息 John:x:1005:1007::/home/John:/bin/bash 解读下含义如下 John 用户名 x 密码（加密） 1005 用户 ID 1007 用户所在组 ID 注释性描述（当前没有） /home/John 用户主目录 /bin/bash 用户登录的 shell 即 用户名 : 密码 : 用户ID : 用户所在组ID : 注释性描述 : 用户主目录 : 用户登录的shell — The End —","link":"/linux/2018/04/14/"},{"title":"linux 使用 crontab 实现任务调度","text":"linux 可以在某个特定的时间内执行特定的程序或命令。比如：定期扫描病毒；定期备份数据库。我们使用 crontab 设置定时任务 常用选项 命令 描述 crontab -e 进入编辑任务 crontab -l 查询任务 crontab -r 删除当前用户所有 crontab 任务 占位符有 5 个占位符： *****，分别代表的时间含义如下 占位符 范围 描述 第一个 * 0-59 一个小时中的第几分钟 第二个 * 0-23 一天中的第几个小时 第三个 * 1-31 一个月中的第几天 第四个 * 1-12 一个年中的第几个月 第五个 * 0-7 一个周中的第几个星期（0 7 都是星期日） 占位符符号5 个占位符，每个都可以用一些特殊的符号表示，特殊符号如下 符号 描述 * 代表任意时间 , 代表不连续的时间 - 代表连续的时间 */n 代表每隔多久 例如： 每天的 8 点、12 点、16 点 都执行一次 10 8,12,16 * * * execute ... 周一到周六凌晨 5 点执行 10 5 * * 1-6 execute ... 每隔 10 分钟执行一次 1*/10 * * * * execute ... 对于简单的任务，可以直接在 crontab 中加入任务即可。对于复杂的任务，需要写脚本 每隔 10 分钟去执行我的 shell 脚本 1*/10 * * * * /home/zhulu/my_shell.sh 重启任务调度服务 service crond restart — The End —","link":"/linux/2018/04/30/"},{"title":"linux 下的 /etc/shadow 文件","text":"— The End —","link":"/linux/2018/04/16/"},{"title":"linux 固定 IP 地址","text":"每次 linux 重启后，发现重新获取的 IP 地址和原来不一样了，这样很不方便，可以通过修改配置文件，固定 IP 在 shell 中输入 ifconfig 查看网络配置 ens33: flags=4163 mtu 1500 inet 192.168.15.35 netmask 255.255.255.0 broadcast 192.168.15.255 inet6 fe80::3e2c:46fb:1ed8:901e prefixlen 64 scopeid 0x20 ether 00:0c:29:d6:2a:dc txqueuelen 1000 (Ethernet) RX packets 167209 bytes 222155294 (211.8 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 69832 bytes 4530334 (4.3 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73 mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10 loop txqueuelen 1000 (Local Loopback) RX packets 172 bytes 14824 (14.4 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 172 bytes 14824 (14.4 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 virbr0: flags=4099 mtu 1500 inet 192.168.122.1 netmask 255.255.255.0 broadcast 192.168.122.255 ether 52:54:00:03:b9:f9 txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 我的网卡是 ens33 ，当前的 IP 是 192.168.15.35 编辑 /etc/sysconfig/network-scripts/ 下的 ifcfg-ens33 文件，下面是编辑后的结果 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy IPADDR=192.168.15.35 GATEWAY=192.168.15.2 DNS1=192.168.15.2 NAME=ens33 UUID=bc8f18e4-3d32-467c-a9d1-ad081adb2d47 DEVICE=ens33 ONBOOT=yes ZONE=public 修改 BOOTPROTO=static 、 IPADDR=192.168.15.35 、ONBOOT=yes 保存后重启生效，需要立即生效执行 service network restart 要确保有 GATEWAY DNS1 这两项 — The End —","link":"/linux/2018/05/02/"},{"title":"linux rpm yum 包管理工具","text":"使用 RPM yum 安装 linux 应用 RPMRPM 是 Redhat Package Manager 的缩写。suse redhat centos 都有采用，成为了行业标准 查询rpm -qa 查询已安装的 rmp 软件包rpm -q package-name 查询某软件包是否安装rpm -qi package-name 查询某软件包信息rpm -ql package-name 查询某软件包内文件rpm -qf absolute-path 查询文件所属软件包 YumYum 是一个 shell 基于 RPM 的前端软件包管理器，能从指定的服务器自动下载 RPM 包并安装，并可以自动处理软件之间的依赖关系。 yum list 查询服务器软件列表yum install package-name 下载并安装 — The End —","link":"/linux/2018/05/12/"},{"title":"linux 文件、目录的权限","text":"linux 中的文件、目录都记录了对应的权限，看看如何记录的。 权限用符号表示 r 用户有读的权限，对应数字 4 w 用户有写的权限，对应数字 2 x 用户有执行的权限，对应数字 1 - 用户无对应的权限 linux 使用 rwx 三个字符为一组来表示用户对文件的操作权限。三个字符的顺序是固定的，没有对应的权限使用 - 表示。 比如 r– 表示用户的权限是 只读 注意 对于文件 w 表示可以修改文件，同时拥有该文件所在目录的写权限，才能删该文件 对于目录 w 表示可以重名目录，可以在目录下 创建、修改、重命名目录 对于目录 r 表示可以使用 ls 命令查看目录下的内容 对于目录 x 表示可以进入目录 文件类型表示 b 块文件（硬盘） c 字符设备（鼠键） d 目录 l 软连接 - 普通文件 命令行输入如下命令查看 /etc 目录下的文件和文件夹 1ls -l /etc 图为结果的一部分 以最后一行为例 drwxr-xr-x. 2 root root 250 9月 19 21:46 yum.repos.d 解读为 drwxr-xr-x. ==> [文件类型][用户权限][用户所在组的成员权限][其他组成员权限]. 2 root root ==> [包含子目录数包括上级目录(..)和当前目录(.)] [文件所有者] [文件所在组] 250 9月 19 21:46 ==> [文件字节大小] [最后修改月份] [最后修改日] [最后修改时间] — The End —","link":"/linux/2018/04/17/"},{"title":"linux 进程","text":"linux 进程查询、服务管理 简介linux 中每个执行的程序（代码）都称为一个进程，每一个进程都分配一个 ID 每一个进程都有一个对应的一个父进程，而这个父进程可以复制多个子进程 进程存在的方式分为前台、后台 系统服务一般都都常驻后台，直到关机 查看进程在 shell 中输入 ps -aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.1 194120 7240 ? Ss 00:06 0:14 /usr/lib/systemd/systemd --switched-root --system --deserialize 22 root 2 0.0 0.0 0 0 ? S 00:06 0:00 [kthreadd] root 3 0.0 0.0 0 0 ? S 00:06 0:02 [ksoftirqd/0] root 4 0.0 0.0 0 0 ? S 00:06 0:01 [kworker/0:0] ... 列 描述 USER 进程所属用户 PID 进程 ID %CPU CUP 占比 %MEM 运存占比 VSZ 虚拟内存使用量 KB RSS 内存使用量 KB TTY 终端名称缩写 STAT 状态：S-休眠, R-运行, D-短暂等待, Z-僵死, N-优先级比“普通”还低, T-被追踪或被停止 START 启动时间 TIME 使用 CUP 总计时间 COMMAND 执行进程的命令行和参数 终止进程kill [pid] 指令可以结束指定 PID 的进程，要强制结束使用 -9 参数 killall [pname] 结束指定名称的进程，支持通配符 * 服务服务（service）的本质是运行在后台的进程，通常会监听某个端口。服务又称守护进程 指令 描述 service srv start service srv stop service srv restart service srv reload service srv status centOS7 不再使用 service ，而使用 systemctl linux 中每个运行级别里服务启动与否是单独设置的 在 shell 中输入 chkconfig 查看服务的在各个运行级别的启动情况 注：该输出结果只显示 SysV 服务，并不包含 原生 systemd 服务。SysV 配置数据 可能被原生 systemd 配置覆盖。 要列出 systemd 服务，请执行 'systemctl list-unit-files'。 查看在具体 target 启用的服务请执行 'systemctl list-dependencies [target]'。 netconsole 0:关 1:关 2:关 3:关 4:关 5:关 6:关 network 0:关 1:关 2:开 3:开 4:开 5:开 6:关 vmware-tools 0:关 1:关 2:开 3:开 4:开 5:开 6:关 vmware-tools-thinprint 0:关 1:关 2:开 3:开 4:开 5:开 6:关 输入 chkconfig [–level n] srvname on|off 来设置某服务是否启动，可以为某个运行级别指定是否启动 在 shell 中输入 setup 可以进入图形设置界面 动态监控进程在 shell 中输入 top [-d n] ，可指定刷新频率，默认是 3s 刷新一次 top - 21:35:00 up 21:28, 2 users, load average: 0.00, 0.01, 0.05 Tasks: 314 total, 1 running, 313 sleeping, 0 stopped, 0 zombie %Cpu(s): 0.0 us, 0.0 sy, 0.0 ni, 99.9 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem : 3863536 total, 730276 free, 1088456 used, 2044804 buff/cache KiB Swap: 2097148 total, 2097148 free, 0 used. 2418308 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 2024 mysql 20 0 1117304 182312 5416 S 0.3 4.7 2:12.34 mysqld 2646 zhulu 20 0 4193212 213284 57192 S 0.3 5.5 0:58.54 gnome-shell 7044 root 20 0 0 0 0 S 0.3 0.0 0:53.46 kworker/1:1 19592 root 20 0 162104 2456 1584 R 0.3 0.1 0:01.94 top 1 root 20 0 194120 7276 4196 S 0.0 0.2 0:16.42 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.13 kthreadd 3 root 20 0 0 0 0 S 0.0 0.0 0:02.73 ksoftirqd/0 4 root 20 0 0 0 0 S 0.0 0.0 0:01.79 kworker/0:0 ... 信息解读 top: 当前时间是 21:35:00 , 系统开机运行了 21:28 , 2 个用户处于登录状态 , 负载均衡 0.00 0.01 0.05Tasks: 共 314 个任务 , 1 个在运行 , 313 个在休眠 , 0 个已停止 , 0 个僵死%Cpu(s): 用户占用 0.0% , 体统占用 0.0% , 0.0 ni , 空闲 99.9% 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem: 运存使用情况KiB Swap: 交换区使用情况 当前界面是可以交互的 输入 P 进程按 CPU 使用率排序输入 M 进程按内存使用率排序输入 N 进程按 PID 使用率排序输入 u 再输入用户名过滤对应用户的进程输入 k 再输入 PID 可以杀死指定进程输入 q 或 CTRL + C 退出 top — The End —","link":"/linux/2018/05/08/"},{"title":"VM 虚拟机的网络连接方式","text":"VM 虚拟机有三种网络连接方式：桥连接模式（B），NAT 模式（N），仅主机模式（H）。它们的含义和区别是什么呢？ VMWare 虚拟机设置网络链接方式，常用的有三种。 桥连接模式（B）在同一个网关内，比如网关地址时 192.168.31.1 ，虚拟机的 ip 和母机的 ip 在同一个网段。网关内的其他计算机可以通过 ip 访问到虚拟机。 NAT 模式（N）即 Network Address Translation （网络地址转换）。母机有两个 ip ，虚拟机与母机处在由 VM 提供的单独的一个网段。虚拟机通过母机的网络上网，可以访问母机所在网段的其它计算机，除母机外的其他计算机访问不到虚拟机。 仅主机模式（H）虚拟机是一个独立的主机，不能访问其他计算机。 — The End —","link":"/linux/2018/02/24/"},{"title":"web 安全预防","text":"针对 XSS、CSRF 攻击的常规做法 预防 XSS主要是服务器要对用户的输入进行编码、过滤、校正， 对用户输入的数据进行 HTML Entity 编码 12345var userInput = '&lt;script&gt; alert(\"hi\") &lt;/script&gt;'var wrapper = document.createElement('div')div.innerText = userInputconsole.log(div.innerHTML)// \"&amp;lt;script&amp;gt; alert(\"hi\") &amp;lt;/script&amp;gt;\" 该方法不转义单引号、双引号 移除用户上传的 DOM 属性，如 onerror 等，移除用户上传的 style 节点，script 节点，iframe 节点等。 避免直接对 HTML Entity 编码，使用 DOM Prase 转换，校正不配对的 DOM 标签。 预防 CSRFHTTP Referer根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。如果该来源地址不可信，则务器拒接请求。 优点：实现成本低缺点：浏览器可设置不提供 Referer，低版本浏览器可篡改 Referer 对关键的 cookie 设置 SameSite=Strict 或 SameSite=Lax，使该 cookie 只能由同站请求携带。 优点：可靠性高缺点：浏览器支持不是很好，通过分享链接进入网站时，存在获取用户登录态失败的问题 验证码用户操作时填写验证码，以确保是用户自己发起的请求 图片验证码 文字验证码 短信验证码 优点：非常可靠缺点：实现成本有点高，用户体验受损 token使用 token 来区分是不是第一方请求 后端随机产生一个 token，把这个 token 保存在 SESSION 状态中；同时，后端把这个 token 交给前端页面 下次前端需要发起请求的时候把这个 token 加入到请求数据或者头信息中，一起传给后端 后端校验前端请求带过来的 token 和 SESSION 里的 token 是否一致 优点：比较可靠 hash后端渲染 html 时，每个表单随机的 hash 值，表单提交时，后端验证 hash 来确认是不是来自第一方请求 优点：比较可靠缺点：实现优点麻烦 — The End —","link":"/security/2017/11/25/"},{"title":"常见的 web 安全问题","text":"因为 HTTP 协议是无状态的，所以很久以前的网站是没有登录这个概念的，直到网景发明 cookie 以后，网站才开始利用 cookie 记录用户的登录状态。浏览器每次 http 请求都会携带 cookie 发个服务器，服务器通过 cookie 记住该用户的状态。但是 cookie 最初被设计成了允许在第三方网站发起的跨站请求携带，这成了 http 一个的安全漏洞。 XSSXSS 是跨站脚本攻击（Cross-Site Scripting）的简称。浏览器错误的将攻击者提供的用户输入数据当做 JavaScript 脚本给执行了 可分为以下几种： Reflected XSS（基于反射的XSS攻击） Stored XSS（基于存储的XSS攻击） DOM-based or local XSS（基于DOM或本地的XSS攻击） 主要依靠站点服务端返回脚本，在客户端触发执行从而发起Web攻击。比如在提交表单时，输入 &lt;script&gt; 标签，或者绑定事件的其他标签，在页面渲染时，如果没有进行转义过滤的话，脚本得以执行。 CSRF跨站请求伪造（Cross-site request forgery），也被称为：one click attack/session riding，缩写为：CSRF/XSRF。攻击者盗用了你的身份信息，以你的名义发送恶意请求 实现前提条件1.用户在浏览器登录百度（www.baidu.com）并产生的 cookie 保留在浏览器里，百度仅以 cookie 为身份验证的凭证。2.在 cookie 未失效时，用同一个浏览器打开了恶意网站 B。 伪造 get 请求实现 get 请求的方式，是借用 img script iframe 的 src 属性，link 标签的 href 属性，用户访问网站时，浏览器解析 html 自动发起请求。还可以通过点击 a 标签，window.location.href 重定向 1234567&lt;head&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"//www.baidu.com/s?ie=UTF-8&amp;wd=web\"/&gt; &lt;script type=\"text/javascript\" src=\"//www.baidu.com/s?ie=UTF-8&amp;wd=web\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;img style=\"display: none\" src=\"//www.baidu.com/s?ie=UTF-8&amp;wd=web\"/&gt;&lt;/body&gt; 你查看控制台，可以看到网站 B 向百度发起了一个 get 请求搜索关键字 web ，并携带了 www.baidu.com 域名下的 cookie ！百度从 cookie 判断，认为是你本人发起的请求。 伪造 post 请求用 ajax 请求默认是不携带 cookie 的，实现 post 请求的方式，是使用隐藏的 form 表单发起 http 请求，用户访问网站时，js 触发表单提交。代码如下： 12345678910111213&lt;iframe name=\"steal\" display=\"none\"&gt; &lt;form method=\"POST\" name=\"logout\" action=\"//www.baidu.com/logout\"&gt; &lt;input type=\"hidden\" name=\"user_id\" value=\"1100114\"&gt; &lt;/form&gt;&lt;/iframe&gt;&lt;script type=\"text/javascript\"&gt;function steal() { iframe = document.frames[\"steal\"]; iframe.document.Submit(\"logout\");}steal()&lt;/script&gt; 可见 post 请求也不见的是安全的 — The End —","link":"/security/2017/11/18/"},{"title":"预防 CSRF 攻击：同站 cookie","text":"http 允许在第三方网站发起对第一方网站的请求中，携带第一方网站的 cookie ，这很不安全。Google 起草了一份草案来改进 HTTP 协议，那就是为 Set-Cookie 响应头新增 SameSite 属性，它用来标明这个 cookie 是个“同站 cookie”，同站 cookie 只能作为第一方 cookie，不能作为第三方 cookie。 SameSite 有两个属性值，分别是 Strict 和 Lax SameSite: Strict严格模式，表明这个 cookie 在任何情况下都不可能作为第三方 cookie，绝无例外。比如说假如 a.com 设置了如下 cookie： 12Set-Cookie: foo=1; SameSite=StrictSet-Cookie: bar=2 当 b.com 向 a.com 发起 http 请求时，bar 这个cooki 会携带在请求中！但对于 foo 这个 cookie ，b.com 向 a.com 发起任何请求都不会携带！ SameSite: Lax宽松模式，比 Strict 放宽了点限制：用户在不同网站之间跳转（由地址栏发起的 http get 请求），则这个 cookie 可以作为第三方 cookie。比如说假如 a.com 设置了如下 cookie：跳转的方式有： a 标签 window.localtion.href = url window.open(url) 123Set-Cookie: foo=1; SameSite=StrictSet-Cookie: bar=2; SameSite=LaxSet-Cookie: baz=3 在 b.com 中通过链接跳转到 a.com 会携带的cookie 有 bar 和 baz，但不会有 foo ！但是由 &lt;script&gt;、&lt;link&gt;、&lt;img&gt;、&lt;iframe&gt; 标签发起的 get 请求，由 &lt;form&gt; 发起的 post 请求中不会携带 bar 这个 cookie。 同站的判断浏览器在判断第三方请求时用的判断逻辑并不是同源策略，而是用了 Public Suffix List 来判断。 a.baidu.com 和 b.baidu.com 是同站 baidu.com 和 baidu.com:8000 是同站 — The End —","link":"/security/2017/12/02/"}],"tags":[{"name":"stack","slug":"stack","link":"/tags/stack/"},{"name":"ajax","slug":"ajax","link":"/tags/ajax/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"code","slug":"code","link":"/tags/code/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"headers","slug":"headers","link":"/tags/headers/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"json","slug":"json","link":"/tags/json/"},{"name":"css3","slug":"css3","link":"/tags/css3/"},{"name":"clock","slug":"clock","link":"/tags/clock/"},{"name":"cubic","slug":"cubic","link":"/tags/cubic/"},{"name":"loader","slug":"loader","link":"/tags/loader/"},{"name":"layout","slug":"layout","link":"/tags/layout/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"tips","slug":"tips","link":"/tags/tips/"},{"name":"tag","slug":"tag","link":"/tags/tag/"},{"name":"entity","slug":"entity","link":"/tags/entity/"},{"name":"media","slug":"media","link":"/tags/media/"},{"name":"tag-attr","slug":"tag-attr","link":"/tags/tag-attr/"},{"name":"html5","slug":"html5","link":"/tags/html5/"},{"name":"command","slug":"command","link":"/tags/command/"},{"name":"directory","slug":"directory","link":"/tags/directory/"},{"name":"runlevel","slug":"runlevel","link":"/tags/runlevel/"},{"name":"excel","slug":"excel","link":"/tags/excel/"},{"name":"xlsx","slug":"xlsx","link":"/tags/xlsx/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"amaze","slug":"amaze","link":"/tags/amaze/"},{"name":"h5-browser","slug":"h5-browser","link":"/tags/h5-browser/"},{"name":"DOM","slug":"DOM","link":"/tags/DOM/"},{"name":"device","slug":"device","link":"/tags/device/"},{"name":"download","slug":"download","link":"/tags/download/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"syntax","slug":"syntax","link":"/tags/syntax/"},{"name":"api","slug":"api","link":"/tags/api/"},{"name":"error","slug":"error","link":"/tags/error/"},{"name":"jquery","slug":"jquery","link":"/tags/jquery/"},{"name":"library","slug":"library","link":"/tags/library/"},{"name":"cache","slug":"cache","link":"/tags/cache/"},{"name":"cdn","slug":"cdn","link":"/tags/cdn/"},{"name":"canvas","slug":"canvas","link":"/tags/canvas/"},{"name":"chart","slug":"chart","link":"/tags/chart/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"i18n","slug":"i18n","link":"/tags/i18n/"},{"name":"module","slug":"module","link":"/tags/module/"},{"name":"snippet","slug":"snippet","link":"/tags/snippet/"},{"name":"RegExpress","slug":"RegExpress","link":"/tags/RegExpress/"},{"name":"standard","slug":"standard","link":"/tags/standard/"},{"name":"void","slug":"void","link":"/tags/void/"},{"name":"webview","slug":"webview","link":"/tags/webview/"},{"name":"disk","slug":"disk","link":"/tags/disk/"},{"name":"group","slug":"group","link":"/tags/group/"},{"name":"passwd","slug":"passwd","link":"/tags/passwd/"},{"name":"crond","slug":"crond","link":"/tags/crond/"},{"name":"shadow","slug":"shadow","link":"/tags/shadow/"},{"name":"IP","slug":"IP","link":"/tags/IP/"},{"name":"package","slug":"package","link":"/tags/package/"},{"name":"permission","slug":"permission","link":"/tags/permission/"},{"name":"process","slug":"process","link":"/tags/process/"},{"name":"VM","slug":"VM","link":"/tags/VM/"},{"name":"cookie","slug":"cookie","link":"/tags/cookie/"}],"categories":[{"name":"js","slug":"js","link":"/categories/js/"},{"name":"http","slug":"http","link":"/categories/http/"},{"name":"npm","slug":"npm","link":"/categories/npm/"},{"name":"css","slug":"css","link":"/categories/css/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"hotkey","slug":"hotkey","link":"/categories/hotkey/"},{"name":"html","slug":"html","link":"/categories/html/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"office","slug":"office","link":"/categories/office/"},{"name":"test","slug":"test","link":"/categories/test/"},{"name":"proxy","slug":"proxy","link":"/categories/proxy/"},{"name":"security","slug":"security","link":"/categories/security/"}]}